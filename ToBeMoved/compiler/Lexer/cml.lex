//package eu.compassresearch.cml.compiler;
// import generic java definitions
import java.util.*;
//import eu.compassresearch.cml.compiler.CmlParser.Lexer;
//import eu.compassresearch.cml.compiler.CmlParser.Location;

class CmlContext {
  
}

class LexicographicalRuntimeException extends RuntimeException
{
  private int pos,line;
  private  String value;
  public LexicographicalRuntimeException(String chars)
    {
      this.pos = CMLToken.curPos;
      this.line = CMLToken.curLine;
      this.value = chars;
    }
  
  @Override
    public String toString()
    {
      return "Offending syntax "+(value != null ? "starting with \""+value+"\" ":"")+"found at line "+(line+1)+" position "+(pos+1);
    }
}

class CMLToken {
  public static int curLine;
  public static int curPos; 

  private int line;
  private int pos;
  protected  String value;
  public CMLToken(String value)
  {
    this.value = value;
    this.line = line;
    this.pos = pos;
  }

  public String getValue()
  {
    return this.value;
  }

  public static void main(String[] args) throws Exception
  {
    try{
    new CmlLexer(System.in).yylex();
    } catch (LexicographicalRuntimeException e)
	{
	  System.out.println(e);
	}
  }
}

class StringToken extends CMLToken {
  static StringToken currentString;
  private StringBuilder currentLine;
  private List<String> lines = new LinkedList<String>();

  private int endLine;
  private int endPos;

  public StringToken(int startLine, int startPos)
  {
    super("\"");
    currentLine = new StringBuilder();
  }

  public void append(String chars)
  {
    currentLine.append(chars);
  }

  public void newLine()
  {
    lines.add(currentLine.toString());
    currentLine = new StringBuilder();
  }

  public void endString(int line, int pos)
  {
    lines.add(currentLine.toString());
    this.endLine = line;
    this.endPos = pos;
    StringBuilder sb = new StringBuilder();
    for(String s : lines)
      sb.append(s);
    super.value = sb.toString();
    lines=null;
  }
}

class CommentBlock extends CMLToken {
  static CommentBlock current;
  private int level;
  StringBuilder content;

  public CommentBlock()
  {
    super("--");
    current=this;
    content=new StringBuilder();
    level = 1;
  }

  public void appendLine(String line)
  {
    this.content.append(line);
  }

  public void increaseLevel()
  {
    level ++;
  }

  public boolean decreaseLevel()
  {
    level--;
    return level == 0;
  }
}

%%
// ******************************************
// *** JFLEX SCANNER GENERATOR DIRECTIVES ***
// ******************************************
// The Lexer output class name 
%class CmlLexer
 //The Lexer interface generated by the parser
%implements CmlParser.Lexer
 //input files will be in unicode
%unicode
 //used when interfacing with bison  
%byaccj
 //%type return type of yylex 
%line
%column
%char
%debug

%{
  
  // placeholder for the reserved word (keyword) table
  static private HashMap<String,Integer> keywords = null;
  
  // initialize the reserved word table as a static constructor
  static {
    keywords = new HashMap<String,Integer>();
    keywords.put("class", CmlParser.CLASS);
    /*
    //keywords.put("#act", LEX_ACT);
    //keywords.put("#active", LEX_ACTIVE);
    //keywords.put("#fin", LEX_FIN);
    //keywords.put("#req", LEX_REQ);
    //keywords.put("#waiting", LEX_WAITING);
    keywords.put("abs", CmlParser.ABS);
    keywords.put("all", CmlParser.ALL);
    keywords.put("always", CmlParser.ALWAYS);
    keywords.put("and", CmlParser.AND);
    keywords.put("atomic", CmlParser.ATOMIC);
    keywords.put("async", CmlParser.ASYNC);
    keywords.put("be", CmlParser.BE);
    keywords.put("bool", CmlParser.BOOL);
    keywords.put("by", CmlParser.BY);
    keywords.put("card", CmlParser.CARD);
    keywords.put("cases", CmlParser.CASES);
    keywords.put("char", CmlParser.CHAR);
    keywords.put("class", CmlParser.CLASS);
    keywords.put("comp", CmlParser.COMP);
    keywords.put("compose", CmlParser.COMPOSE);
    keywords.put("conc", CmlParser.CONC);
    keywords.put("cycles", CmlParser.CYCLES);
    keywords.put("dcl", CmlParser.DCL);
    keywords.put("def", CmlParser.DEF);
    keywords.put("dinter", CmlParser.DINTER);
    keywords.put("div", CmlParser.ARITHMETIC_INTEGER_DIVISION);
    keywords.put("do", CmlParser.DO);
    keywords.put("dom", CmlParser.DOM);
    keywords.put("dunion", CmlParser.DUNION);
    keywords.put("duration", CmlParser.DURATION);
    keywords.put("elems", CmlParser.ELEMS);
    keywords.put("else", CmlParser.ELSE);
    keywords.put("elseif", CmlParser.ELSEIF);
    keywords.put("end", CmlParser.END);
    keywords.put("error", CmlParser.ERROR);
    keywords.put("errs", CmlParser.ERRS);
    keywords.put("exists", CmlParser.EXISTS);
    keywords.put("exists1", CmlParser.EXISTS1);
    keywords.put("exit", CmlParser.EXIT);
    keywords.put("ext", CmlParser.EXT);
    keywords.put("false", CmlParser.bool_false);
    keywords.put("floor", CmlParser.FLOOR);
    keywords.put("for", CmlParser.FOR);
    keywords.put("forall", CmlParser.FORALL);
    keywords.put("from", CmlParser.FROM);
    keywords.put("functions", CmlParser.FUNCTIONS);
    keywords.put("hd", CmlParser.HD);
    keywords.put("if", CmlParser.IF);
    keywords.put("in", CmlParser.IN);
    keywords.put("inds", CmlParser.INDS);
    keywords.put("inmap", CmlParser.INMAP);
    keywords.put("instance", CmlParser.INSTANCE);
    keywords.put("int", CmlParser.INT);
    keywords.put("inter", CmlParser.SET_INTERSECTION);
    keywords.put("inv", CmlParser.INV);
    keywords.put("inverse", CmlParser.INVERSE);
    keywords.put("iota", CmlParser.IOTA);
    keywords.put("is", CmlParser.IS);
    keywords.put("is_", CmlParser.IS_);
    keywords.put("isofbaseclass", CmlParser.ISOFBASECLASS);
    keywords.put("isofclass", CmlParser.ISOFCLASS);
    keywords.put("lambda", CmlParser.LAMBDA);
    keywords.put("len", CmlParser.LEN);
    keywords.put("let", CmlParser.LET);
    keywords.put("map", CmlParser.MAP);
    keywords.put("merge", CmlParser.DMERGE);
    keywords.put("mk_", CmlParser.MK_);
    keywords.put("mod", CmlParser.MOD);
    keywords.put("mu", CmlParser.MU);
    keywords.put("munion", CmlParser.MAP_MERGE);
    keywords.put("mutex", CmlParser.MUTEX);
    keywords.put("nat", CmlParser.NAT);
    keywords.put("nat1", CmlParser.NATONE);
    keywords.put("new", CmlParser.NEW);
    keywords.put("nil", CmlParser.NIL);
    keywords.put("not", CmlParser.NOT);
    keywords.put("of", CmlParser.OF);
    keywords.put("operations", CmlParser.OPERATIONS);
    keywords.put("or", CmlParser.OR);
    keywords.put("others", CmlParser.OTHERS);
    keywords.put("per", CmlParser.PER);
    keywords.put("periodic", CmlParser.PERIODIC);
    keywords.put("post", CmlParser.POST);
    keywords.put("power", CmlParser.POWER);
    keywords.put("pre", CmlParser.PRE);
    keywords.put("pre_", CmlParser.PRECONDAPPLY);
    keywords.put("private", CmlParser.PRIVATE);
    keywords.put("protected", CmlParser.PROTECTED);
    keywords.put("psubset", CmlParser.PROPER_SUBSET);
    keywords.put("public", CmlParser.PUBLIC);
    keywords.put("rat", CmlParser.RAT);
    keywords.put("rd", CmlParser.RD);
    keywords.put("real", CmlParser.REAL);
    keywords.put("rem", CmlParser.REM);
    keywords.put("responsibility", CmlParser.RESPONSIBILITY);
    keywords.put("return", CmlParser.RETURN);
    keywords.put("reverse", CmlParser.REVERSE);
    keywords.put("rng", CmlParser.RNG);
    keywords.put("samebaseclass", CmlParser.SAMEBASECLASS);
    keywords.put("sameclass", CmlParser.SAMECLASS);
    keywords.put("self", CmlParser.SELF);
    keywords.put("seq", CmlParser.SEQ);
    keywords.put("seq1", CmlParser.SEQ1);
    keywords.put("set", CmlParser.SET);
    keywords.put("skip", CmlParser.SKIP);
    keywords.put("specified", CmlParser.SPECIFIED);
    keywords.put("st", CmlParser.ST);
    keywords.put("start", CmlParser.START);
    keywords.put("startlist", CmlParser.STARTLIST);
    keywords.put("static", CmlParser.STATIC);
    keywords.put("subclass", CmlParser.SUBCLASS);
    keywords.put("subset", CmlParser.SUBSET);
    keywords.put("sync", CmlParser.SYNC);
    keywords.put("system", CmlParser.SYSTEM);
    keywords.put("then", CmlParser.THEN);
    keywords.put("thread", CmlParser.THREAD);
    keywords.put("threadid", CmlParser.THREADID);
    keywords.put("time", CmlParser.TIME);
    keywords.put("tixe", CmlParser.TIXE);
    keywords.put("tl", CmlParser.TL);
    keywords.put("to", CmlParser.TO);
    keywords.put("token", CmlParser.TOKEN);
    keywords.put("trap", CmlParser.TRAP);
    keywords.put("true", CmlParser.bool_true);
    keywords.put("types", CmlParser.TYPES);
    keywords.put("undefined", CmlParser.UNDEFINED);
    keywords.put("union", CmlParser.SET_UNION);
    keywords.put("values", CmlParser.VALUES);
    keywords.put("variables", CmlParser.VARIABLES);
    keywords.put("while", CmlParser.WHILE);
    keywords.put("with", CmlParser.WITH);
    keywords.put("wr", CmlParser.WR);
    keywords.put("yet", CmlParser.YET);
    */
  }


  private Object yylvalue;
    /**
     * Method to retrieve the beginning position of the last scanned token.
     * @return the position at which the last scanned token starts.  */
  public Position getStartPos () { return new Position(yyline,yycolumn); }

    /**
     * Method to retrieve the ending position of the last scanned token.
     * @return the first position beyond the last scanned token.  */
  public Position getEndPos () { return null; }

    /**
     * Method to retrieve the semantic value of the last scanned token.
     * @return the semantic value of the last scanned token.  */
  public Object getLVal () { return yylvalue; }
  
    /**
     * Entry point for error reporting.  Emits an error
     * referring to the given location in a user-defined way.
     *
     * @param loc The location of the element to which the
     *                error message is related
     * @param s The string for the error message.  */
  public void yyerror (CmlParser.Location loc, String s) { return ; }

  // ************************************
  // *** AUXILIARY PRIVATE OPERATIONS ***
  // ************************************

  // helper function for checking reserved words and identifiers
  private int checkIdentifier(String id) {
    yylvalue = yytext();
    //Long line = new Long(yyline+1);
    //Long column = new Long(yycolumn+1);
    try {
      if (keywords.containsKey(id)) {
	//return new OmlLexem(line, column, new Long(keywords.get(id)), id, IOmlLexem.ILEXEMKEYWORD);
	return CmlParser.IDENTIFIER;
      } else {
	//DEBUG String theText = yytext();
	//DEBUG System.out.print(theText + " = ");
	//DEBUG for (int idx=0; idx< theText.length(); idx++) System.out.format("%04x ", (int) theText.charAt(idx));
	//DEBUG System.out.println();
	//return new OmlLexem(line, column, new Long(LEX_identifier), id, IOmlLexem.ILEXEMIDENTIFIER);
	return CmlParser.IDENTIFIER;
      }
    }
    catch (Exception cge) {
      cge.printStackTrace();
      return -1;
    }
  }
  
  // helper function for default token creation
  private int defaultToken()
  {
    return createToken(yytext().charAt(0));
  }
  
  private int createToken(int lex)
  {
    //Long line = new Long(yyline+1);
    //Long column = new Long(yycolumn+1);
    //Long lexem = new Long(lex);
    try {
      yylvalue = yytext();
      //return new OmlLexem(line, column, lexem, yytext(), tp);
      return lex;
    }
    catch (Exception cge) {
      cge.printStackTrace();
      return -1;
    }
  }
  
%}

// *****************************
// *** SHORTHAND DEFINITIONS ***
// *****************************

ucode					= [\u0100-\ufff0]
hexdigit 				= [0-9ABCDEF]|[0-9abcdef]
hexquad 				= {hexdigit}{hexdigit}{hexdigit}{hexdigit}
universalcharactername  = (\\u{hexquad})|(\\U{hexquad})
letter 					= [A-Za-z]|#[A-Za-z]|{universalcharactername}|{ucode}
digit 					= [0-9]
prime 					= \`
hook 					= \~
rtfuniversalcharacter	= \\u{hexquad}[A-Za-z]
identifierorkeyword		= {letter}([0-9\'_]|{letter})*

numericliteral 			= {digit}+
realliteral				= [0-9]+(("."[0-9]+)|([Ee]("+"|"-")?[0-9]+)|("."[0-9]+[Ee]("+"|"-")?[0-9]+))

embeddedctrlchar 		= [\000-\037]
backslashed				= \\c.|\\x..|\\[\\nrabtvef\'\"]|\\[0-3][0-7][0-7]
highbitchar				= [\200-\377]
deletechar				= \177
characterliteral		= "'"([\040-\133\135-\176]|{embeddedctrlchar}|{backslashed}|{deletechar}|{highbitchar}|{universalcharactername}|{rtfuniversalcharacter}|{ucode})"'"

textliteral				= \"([\040-\041\043-\133\135-\176]|{embeddedctrlchar}|{backslashed}|{deletechar}|{highbitchar}|{universalcharactername}|{ucode})*\"

quoteliteral 			= \<{identifierorkeyword}\>

eolc1					= --[^\r\n]*
eolc2					= \/\/[^\r\n]*
eolcomment				= {eolc1}|{eolc2}
comment					= "/*" [^*] ~"*/" | "/*" "*"+ "/"

separator 				= [ \t\r\n]
separators				= {separator}+

range					= ","({separator}*)"..."({separator}*)","

%%

// ********************************
// *** SCANNER PRODUCTION RULES ***
// ********************************

// in-line and multi-line comments
{eolcomment}							{ /*return createToken(CmlParser.COMMENT, OmlLexem.ILEXEMLINECOMMENT);*/ }
{comment}								{ 
  									  /*if (yytext().indexOf('\n') != -1) {
			     					            return createToken(CmlParser.COMMENT, OmlLexem.ILEXEMBLOCKCOMMENT);
  								          } else {
								           return createToken(CmlParser.COMMENT, OmlLexem.ILEXEMLINECOMMENT);
									   }*/
									}					  
								
// production rules for literals
{characterliteral}						{ return createToken(CmlParser.char_lit); }
{quoteliteral}							{ return createToken(CmlParser.quote_lit); }
{textliteral}							{ return createToken(CmlParser.text_lit); }
{realliteral}							{ return createToken(CmlParser.real_lit); }
{numericliteral}						{ return createToken(CmlParser.num_lit); }

// keywords and identifiers
"not"{separators}"in"{separators}"set"	{ return createToken(CmlParser.NOTINSET); }
"in"{separators}"set"					{ return createToken(CmlParser.INSET); }

"is_"/{identifierorkeyword} 			{ return createToken(CmlParser.IS_); }
"mk_"/{identifierorkeyword} 			{ return createToken(CmlParser.MK_); }
{identifierorkeyword}					{ return checkIdentifier(yytext()); }
\${identifierorkeyword} 				{ return createToken(CmlParser.dollar_identifier); }

// multi character tokens
{range}									{ return createToken(CmlParser.RANGE_OVER); }
"==>"									{ return createToken(CmlParser.OPERATIONARROW); }
"<=>"									{ return createToken(CmlParser.BIMPLY); }
"|->"									{ return createToken(CmlParser.BAR_ARROW); }
"<-:"									{ return createToken(CmlParser.MAP_DOMAIN_RESTRICT_BY); }
":->"									{ return createToken(CmlParser.MAP_RANGE_RESTRICT_BY); }
":-"									{ return createToken(CmlParser.DONTCARE); }
".#"									{ return createToken(CmlParser.DOTHASH); }
"<="									{ return createToken(CmlParser.LTE); }
">="									{ return createToken(CmlParser.GTE); }
"<>"									{ return createToken(CmlParser.NEQ); }
"->"									{ return createToken(CmlParser.RARROW); }
"+>"									{ return createToken(CmlParser.TARROW); }
"=>"									{ return createToken(CmlParser.IMPLY); }
"=="									{ return createToken(CmlParser.IS_DEFINED_AS); }
"||"									{ return createToken(CmlParser.NONDET); }
":="									{ return createToken(CmlParser.ASSIGN); }
"::"									{ return createToken(CmlParser.DOUBLE_COLON); }
"**"									{ return createToken(CmlParser.EXP_OR_ITERATE); }
"++"									{ return createToken(CmlParser.MODIFY_BY); }
"<:"									{ return createToken(CmlParser.MAP_DOMAIN_RESTRICT_TO); }
":>"									{ return createToken(CmlParser.MAP_RANGE_RESTRICT_TO); }
"$$"									{ return createToken(CmlParser.LAST_RESULT); }

// single character tokens
{hook}									{ return createToken(CmlParser.HOOK); }
{prime}									{ return createToken(CmlParser.PRIME); }
","										{ return defaultToken(); }
"!"										{ return defaultToken(); }
":"										{ return defaultToken(); }
";"										{ return defaultToken(); }
"="										{ return createToken(CmlParser.EQUALS); }
")"										{ return defaultToken(); }
"("										{ return defaultToken(); }
"|"										{ return defaultToken(); }
"-"										{ return defaultToken(); }
"["										{ return defaultToken(); }
"]"										{ return defaultToken(); }
"{"										{ return defaultToken(); }
"}"										{ return defaultToken(); }
"+"										{ return defaultToken(); }
"/"										{ return defaultToken(); }
"<"										{ return createToken(CmlParser.LT); }
">"										{ return createToken(CmlParser.GT); }
"."										{ return defaultToken(); }
"&"										{ return createToken(CmlParser.DOT); }
"*"										{ return defaultToken(); }
"^"										{ return createToken(CmlParser.CONC); }
"\\"									{ return createToken(CmlParser.SETDIFF); }

// handle white space and new-lines
{separator}								{ /* IGNORE */ }

// default catch-all production rule is to return the current character
.										{ return defaultToken(); }

// production rule to handle end-of-file
<<EOF>>									{ return -1; }
/*
newline=\n
ws=[\t ]
digit=[0-9]
digits={digit}*
decdigits=[1-9][0-9]*
octdigits=0[1-7][0-7]*
identifier=[a-zA-Z$_][0-9a-zA-Z$_]*
equalsign==
minus=-
plus=\+
times=\*
divide=\/
backslash=\\
lbrace=\{
rbrace=\}
lparen=\(
rparen=\)
lbrack=\[
rbrack=\]
quote=\"
colon=:
semicolon=;
string=[^\"]*
gt=>
lt=<
at=@
comma=,
KW_Class=class
KW_for=for
KW_if=if
KW_then=then
KW_else=else
KW_define=define
KW_begin=begin
KW_end=end
KW_externalChoice=\[\]
KW_assign=:=
%state STRING, STRINGESCAPE, COMMENT
%%
<YYINITIAL>--               { yybegin(COMMENT);  }
<COMMENT>--                 { /* Todo pick up the comment */  }
<COMMENT>\/\*               { yybegin(COMMENT); }
<COMMENT>.*                 { /* We have read one line of comment add it */ }
<COMMENT>{newline}          { /* Handle newlines in block if it is a '--' block the return the token */  }

<YYINITIAL>{quote}         { yybegin(STRING);}
<STRING>{newline}          { /*Handle new line in a string */}
<STRING>{backslash}        { yybegin(STRINGESCAPE);}
<STRING>{string}           { /*Handle every character not being a double quote or newline */}
<STRINGESCAPE>{quote}      { yybegin(STRING); /*Only quote needs to be escaped everything else 
						can be in a string so far */ }
<STRING>{quote}            { yybegin(YYINITIAL); /* Return string token */ }

<YYINITIAL>{newline       { /* Nothing to do really */ }
<YYINITIAL>{ws}            { /* Eat white space */ }
<YYINITIAL>{decdigits}     { /* TODO */ }
<YYINITIAL>{octdigits}     { /* TODO */ }
<YYINITIAL>{identifier}    { 
                             yylvalue = yytext();
                             return CmlParser.IDENTIFIER;
			   }
<YYINITIAL>{equalsign}     { 
                             yylvalue = yytext();
                             return CmlParser.EQUALS; 
			   }
<YYINITIAL>{minus}         { 
                             yylvalue = yytext();
                             return CmlParser.MINUS;
			   }
<YYINITIAL>{plus}          { 
                             yylvalue = yytext();
                             return CmlParser.PLUS;
			   }
<YYINITIAL>{times}         { /* TODO */ }

<YYINITIAL>{divide}        { 
                             yylvalue = yytext();
                             return CmlParser.DIV;
			   }
<YYINITIAL>{backslash}     { /* TODO */ }

<YYINITIAL>{lbrace}        { 
                             yylvalue = yytext();
                             return CmlParser.LCURLY;
			   }
<YYINITIAL>{rbrace}        { 
                             yylvalue = yytext();
                             return CmlParser.RCURLY;
			   }
<YYINITIAL>{lparen}        { 
                             yylvalue = yytext();
                             return CmlParser.LPAREN;
			   }
<YYINITIAL>{rparen}        { 
                             yylvalue = yytext();
                             return CmlParser.RPAREN;
			   }
<YYINITIAL>{lbrack}        { 
                             yylvalue = yytext();
                             return CmlParser.LSQUARE;
			   }
<YYINITIAL>{rbrack}        { 
                             yylvalue = yytext();
                             return CmlParser.RSQUARE;
			   }
<YYINITIAL>{colon}         { 
                             yylvalue = yytext();
                             return CmlParser.COLON;
			   }
<YYINITIAL>{semicolon}     { 
                             yylvalue = yytext();
                             return CmlParser.SEMI;
			   }
<YYINITIAL>{at}            { 
                             yylvalue = yytext();
                             return CmlParser.AT;
			   }
<YYINITIAL,STRING>.        { throw new LexicographicalRuntimeException(yytext());}
*/
