types

Command = Borrow | Renew | Return | Find;

Borrow :: copy : BookId
          user : UserId;
          
Renew :: copy : BookId
         user : UserId;
         
Return :: copy : BookId;

Find :: string : seq of char;

BookId = token;

UserId = token;

BorrowMap = map UserId to set of BookId;

Library ::
  books : map BookId to Book
  users : map UserId to User
  borrowed : BorrowMap;

Book ::
  title : seq of char
  author : seq of char;
  
User ::
  name : seq of char;
  
functions

ExeBorrow: Borrow * Library -> Library
ExeBorrow(mk_Borrow(c,u), mk_Library(bs,us,bor)) ==
  mk_Library(bs,us,bor ++ {u |-> BorrowCopy(u,c,bor)})
pre c in set dom bs and
    u in set dom us and
    c not in set dunion rng bor;
    
BorrowCopy: UserId * BookId * BorrowMap -> set of BookId
BorrowCopy(u,c,bor) ==
  if u in set dom bor
  then bor(u) union {c}
  else {c};

ExeRenew: Renew * Library -> Library
ExeRenew(mk_Renew(c,u), mk_Library(bs,us,bor)) ==
  mk_Library(bs,us,bor ++ {u |-> BorrowCopy(u,c,bor)})
pre c in set dom bs and
    u in set dom us and
    c not in set dunion rng bor;
  