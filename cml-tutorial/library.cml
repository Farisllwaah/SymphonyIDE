
  
channels
-- initialisation channel
	init;
-- channels that execute single operations
	borrow: Borrow;
	return: Return;
	find: Find;
-- channels that execute multiple operations
	renew: Renew;	
-- channels that do not execute operations
	loans: UserId*nat;

process LibraryProcess
	state library: Library
		inv dom(library.borrowed) = dom(users)
		    and rng(library.borrowed) subseq dom(library.books)
	operations
		Init: (map BookId to Book)*(map UserId to User) -> Library
		Init(bs,us) == library := mk_Library(bs,us,{|->})
	actions
		Act = (
			borrow?b:pre_ExeBorrow(b,library) -> library := ExeBorrow(b,library)
			[]
			renew?r:pre_ExeReturn(mk_Return(r.book),library) -> 
				library := ExeReturn(mk_Return(r.book),library);
				library := ExeBorrow(r,library)
			[]
			return?r:pre_ExeReturn(r,library) -> library := ExeReturn(r,library)
			[]
			find?f:pre_ExeFind(f,library) -> library := ExeFind(f,library)
			[]
			loans?u:(u in set dom(library.borrowed))!(card(library.borrowed(u))) -> SKIP 
		); Act
	@ init -> Init(); Act
end

channels
	initUser: UserId
	success, error

process Scenario1 = i: UserId
	state
		books: set of BookId;
		id: UserId;
		inv card(books) < 5
	
	operations
		Init: () -> ()
		Init == id := i; books = {}; 
	
	@ initUser?u -> Init(u); borrow!mk_Borrow(book1,id) -> books := books union {book1};
			borrow!mk_Borrow(book2,id) -> books := books union {book2};
			return!mk_Return(book1) -> books := books \ {book1};
			loans!id?s -> if s = books then success -> SKIP else error -> SKIP
	
process Scenario2 = i: UserId
	state
		books: set of BookId;
		id: UserId;
		inv card(books) < 5
	
	operations
		Init: () -> ()
		Init == id := i; books = {}; 
			
	@ initUser?u -> Init(u); borrow!mk_Borrow(book1,id) -> books := books union {book1}
			return!mk_Return(book2) -> books := books \ {book2}
	
chansets
	Interface = {|init, initUser, borrow, renew, return ,find, loans|}
	
process Test1 = (LibraryProcess [| Interface |] Scenario1(user1))
process Test2 = (LibraryProcess [| Interface |] Scenario2(user1))