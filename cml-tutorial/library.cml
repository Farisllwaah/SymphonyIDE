types

Command = (Borrow | (Renew | (Return | Find)));

String = seq of char;

BookId = token;

UserId = token;        

BorrowMap = map UserId to set of BookId;

-- the parser forces record declarations to have access modifiers

public Borrow :: copy : BookId
          user : UserId;
          
public Renew :: copy : BookId
         user : UserId;
         
public Return :: copy : BookId;

public Find :: string : String;

public Library ::
  books : map BookId to Book
  users : map UserId to User
  borrowed : BorrowMap
--inv mk_Library(bs,us,bor) ==
--  dom bor subset dom us and
--  dunion rng bor subset dom bs and
-- forall u1, u2 in set dom bor & u1 <> u2 => bor(u1) inter bor(u2) = {}
;

public Book ::
  title : String
  author : String;
  
public User ::
  name : String;
 
functions

ExeBorrow: Borrow * Library -> Library
ExeBorrow(b,l) ==
	mk_Library(l.books,l.users,l.borrowed++{u |-> BorrowCopy(b.user,b.copy,b.borrowed)})
pre b.copy in set dom b.books and
	b.user in set dom b.users and
	b.copy not in set dunion rng l.borrowed
--ExeBorrow(mk_Borrow(c,u), mk_Library(bs,us,bor)) ==
--  mk_Library(bs,us,bor ++ {u |-> BorrowCopy(u,c,bor)})
--pre c in set dom bs and
--    u in set dom us and
--    c not in set dunion rng bor
;

    
BorrowCopy: UserId * BookId * BorrowMap -> set of BookId
BorrowCopy(u,c,bor) ==
  if u in set dom bor
  then bor(u) union {c}
  else {c};	
  
  
ExeReturn: Return * Library -> Library
ExeReturn(r, l) ==
  mk_Library(l.books,l.users,RemoveCopy(r.copy,l.borrowed))
pre r.copy in set dom l.books
--ExeReturn(mk_Return(c), mk_Library(bs,us,bor)) ==
--  mk_Library(bs,us,RemoveCopy(c,bor))
--pre c in set dom bs
;

RemoveCopy: BookId * BorrowMap -> BorrowMap
RemoveCopy(c,bor) ==
  {u |-> bor(u)\{c} | u in set dom bor};
  
ExeFind: String * Library -> set of BookId
ExeFind(s,l) ==
   {bid | bid in set dom l.books & s in set {l.books(bid).title, l.books(bid).author}} 
  
channels
	init;
	borrow: Borrow;
	return: Return;
	find: Find;
	renew: Renew;	
	loans: UserId*nat
	
process LibraryProcess = begin
	state library: Library;
		inv dom(library.borrowed) = dom(users) 
		and rng(library.borrowed) subset dom(library.books)
	
	operations
		Init(bs: map BookId to Book, us: map UserId to User)
		post library = mk_Library(bs,us,{|->})
		
	actions
		Act = (
			borrow?b:pre_ExeBorrow(b,library) -> library := ExeBorrow(b,library)
			[]
			renew?r:pre_ExeReturn(mk_Return(r.book),library) -> 
				library := ExeReturn(mk_Return(r.book),library);
				library := ExeBorrow(r,library)
			[]
			return?r:pre_ExeReturn(r,library) -> library := ExeReturn(r,library)
			[]
			find?f:pre_ExeFind(f,library) -> library := ExeFind(f,library)
			[]
			loans?u:(u in set dom(library.borrowed))!(card(library.borrowed(u))) -> SKIP 
		); Act
	
	@ SKIP --init -> Init(); Act
end
