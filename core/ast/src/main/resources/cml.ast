//TODO1: maybe generate classes with the Comparable interface 
Packages
base eu.compassresearch.ast.node;
analysis eu.compassresearch.ast.analysis;

Tokens
  java_File = 'java:java.io.File';
  java_Stream = 'java:java.io.InputStream';


Abstract Syntax Tree

source {->  package='eu.compassresearch.ast.program'}
      = {file} [name]: java_String (file): java_File
      | {tcpStream} [ip]: java_String [port]: java_String (stream): java_Stream 
      | {inputStream} [origin]: java_String (stream): java_Stream
      ;

/*
 Declarations 
*/
declaration {-> package='eu.compassresearch.ast.declarations'}
    = #Single
	;

#Single {-> package='eu.compassresearch.ast.declarations'}
	= {type}  
    	[identifiers]:LexIdentifierToken* 
    	(type):type
	| {expression}
    	[identifiers]:LexIdentifierToken* 
    	[expression]:exp
    ;
/*
 Definitions 
*/
definition {-> package='eu.compassresearch.ast.definitions'}
    =   {action} 
    		[declarations]:declaration.#Single.type* 
    		[action]:action
    |   {chanset} 
    		[identifier]:LexIdentifierToken 
    		[chansetExpressions]:exp
    |   {invariant} 
    		[pattern]: pattern 
    		(expression): exp
    |   #operation    
    |   #paragraph
    |   {process}
    		[localState]: declaration*
	     	[process]: process
    | {channelName} 
    	[singleType]: declaration.#Single.type
    ;
    

#paragraph {-> package='eu.compassresearch.ast.definitions'}
	  =  {class}
	   		[body]: definition*
	   		(supertypes):type* 
           	(supernames):LexNameToken*// try out () 
           	(definitions):definition* 
           	(allInheritedDefinitions):definition*
           	(localInheritedDefinitions):definition* 
           	[hasContructors]:java_Boolean
           	[settingHierarchy]:ClassDefinitionSettings
	   		(superDefs):definition.#paragraph.class*	
			[gettingInheritable]:java_Boolean
			(superInheritedDefinitions):definition*
			[gettingInvDefs]:java_Boolean
			[isAbstract]:java_Boolean
			[isUndefined]:java_Boolean
			(classtype):type
			(isTypeChecked):java_Boolean
			(invariant):definition.#operation.explicit
	   | {process} 
	     	[processDefinition]: definition.process
	   | {channel} 
	   		[channelNameDeclarations]: definition.channelName*
	   | {chanset} 
	     	[chansets] : definition.chanset*
 	   | {action} 
 	   		[actions]: definition.action*
 	   | {types} 
 	   		[types]: definition.type*
 	   | {operation} 
 	   		[operations]:definition.#operation*
 	   | {function} 
 	   		[functionDefinitions]:definition*
 	   | {value} 
 	   		[valueDefinitions]: definition*
 	   | {initial} 
 	   		[operationDefinition]: definition
 	   | {state} 
    		[fields]:field.field* 
            [invPattern]:pattern [invExpression]:exp (invdef):definition.explicitFunction
            [initPattern]:pattern [initExpression]:exp (initdef):definition.explicitFunction
            (stateDefs):definition* 
	   ;
    
#operation {-> package='eu.compassresearch.ast.definitions'}
	=   {explicit} 			[parameterPatterns]:pattern* 
                            [body]:action.#Statement
                            [precondition]:exp 
                            [postcondition]:exp 
                            
                            (type):type.operation
                            
                            (predef):definition.explicitFunction
                            (postdef):definition.explicitFunction
                            (paramDefinitions):definition*
                            (state):definition.#paragraph.state
                            
                            (actualResult):type
                            [isConstructor]:java_Boolean
                            
    |   {implicit} 			[parameterPatterns]:pair.patternListType*
                            [result]:pair.patternType*
                            //[body]:stm
                            [externals]:clause.external*
                            [precondition]:exp 
                            [postcondition]:exp
                            [errors]:case.error*
                            
                            (type):type.operation
                            (predef):definition.explicitFunction
                            (postdef):definition.explicitFunction
                            (state):definition.#paragraph.state
                            (actualResult):type
                            (stateDefinition):definition
                            [isConstructor]:java_Boolean    
    ;

/*
    Expressions
*/    
exp {-> package='eu.compassresearch.ast.expressions'}
    =   {bracketed} [expression]:exp /*cml*/
    |   #Set
    |   {stateInit} (state):definition.#paragraph.state  
    |   {tupleSelect} [tuple]:exp [entry]:java_Integer 
    |   #Channel
    | 	{unresolvedPath} [identifiers]:LexIdentifierToken*
    ;
    
#Channel  {-> package='eu.compassresearch.ast.expressions'}
	= #Rename
	| {name} [identifier]:LexNameToken [dotExpressions]:exp*
	;
	
#Rename   {-> package='eu.compassresearch.ast.expressions'}
 	= {comprehension} [renamePairs]:pair.rename [bindings]:multipleBind* [predicate]:exp
 	| {enumeration} [renamePairs]:pair.rename*
    ;
    
#Set {-> package='eu.compassresearch.ast.expressions'}
    =   #Chanset
    ;
    
#Chanset {-> package='eu.compassresearch.ast.expressions'}
	= {identifier} [identifier]:LexIdentifierToken
	| {enum} [identifiers]:LexIdentifierToken*
	| {comp} [channelNameExp]:exp.#Channel.name [bindings]:multipleBind* [predicate]:exp 
    ;
    
/* 
	Types 
*/

type {-> package='eu.compassresearch.ast.types'}
    =   {statement} // marker that a statement is typed ok
    |   {process} // marker that a process is typed ok
    |   {error} // marker that type of a subtree has failed 
    |   {processParagraph} // marker stipulating process paragraph is typed ok
    |   {chansetParagraph} // marker stipulating a chanset paragraph is typed ok
    |   {channelsParagraph} // marker stipulating a chanset paragraph is typed ok
    |   {actionParagraph} // marker stipulating that a Action Paragraph is typed ok
    |   {valueParagraph} // marker stipulating that a Values paragraph is typed ok
    |   {functionParagraph} // marker stipulating that a Function Paragraph is typed ok
    |   {typeParagraph} // marker stipulating that a Types Paragraph is typed ok
    |   {operationParagraph} // marker stipulating that a Function Paragraph is typed ok
    |   {stateParagraph} // marker stipulating that a state Paragraph is typed ok
    |   {source} // marker stipulating a source was typed ok
    |   {channel} (type):type // marker stipulating that a channel Paragraph is typed ok
    ; 

access  {-> package='eu.compassresearch.ast.definitions'}
    =   {logical}
    ;

/* 
	Patterns 
*/
    
pair {-> package='eu.compassresearch.ast.patterns'}
    = {rename} [from]:exp.#Channel.name [to]:exp.#Channel.name
    ; 

/*
	Process
*/
process {-> package='eu.compassresearch.ast.process'}
	= {state} 
		[definitionParagraphs]:definition.#paragraph* 
		[action]:action
	| {sequentialComposition} 
		[left]:process 
		[right]:process
	| {externalChoice} 
		[left]:process 
		[right]:process
	| {internalChoice} 
		[left]:process 
		[right]:process
	| {generalisedParallelism} 
		[left]:process 
		[chansetExpression]:exp 
		[right]:process
	| {alphabetisedParallelism} 
		[left]:process 
		[leftChansetExpression]:exp 
		[rightChansetExpression]:exp 
		[right]:process
	| {synchronousParallelism} 
		[left]:process 
		[right]:process
	| {interleaving} 
		[left]:process 
		[right]:process
	| {interrupt} 
		[left]:process 
		[right]:process
	| {timedInterrupt} 
		[left]:process 
		[timeExpression]:exp 
		[right]:process
	| {untimedTimeout} 
		[left]:process 
		[right]:process
	| {timeout} 
		[left]:process 
		[timeoutExpression]:exp 
		[right]:process
	| {hiding} 
		[left]:process 
		[chansetExpression]:exp
	| {startDeadline} 
		[left]:process 
		[expression]:exp
	| {endDeadline} 
		[left]:process 
		[expression]:exp
	| {instantiation} 
		[declarations]:declaration.#Single.type* 
		[processName]:LexNameToken 
		(processDefinition): definition.process 
		[args]:exp*
	| {channelRenaming} 
		[process]:process 
		[renameExpression]:exp.#Channel.#Rename
	| #Replicated
	;

#Replicated {-> package='eu.compassresearch.ast.process'}
	= {sequentialComposition}  
	| {externalChoice}
	| {internalChoice}
	| {generalisedParallelism} 
		[chansetExpression]:exp
	| {alphabetisedParallelism} 
		[chansetExpression]:exp
	| {synchronousParallelism}
	| {interleaving} 
	;	


/* 
	Actions 
*/
action {-> package='eu.compassresearch.ast.actions'}
	= {skip}
	| {stop}
	| {chaos}
	| {div}
	| {wait} 
		[expression]:exp
	| {communication} 
		[identifier]:LexIdentifierToken 
		[communicationParameters]:communicationParameter* 
		[action]:action
	| {guarded} 
		[expression]:exp 
		[action]:action
	| {sequentialComposition} 
		[left]:action 
		[right]:action
	| {externalChoice} 
		[left]:action 
		[right]:action
	| {internalChoice} 
		[left]:action 
		[right]:action
	| {interrupt} 
		[left]:action 
		[right]:action
	| {timedInterrupt} 
		[left]:action 
		[right]:action 
		[timeExpression]:exp
	| {untimedTimeout} 
		[left]:action 
		[right]:action
	| {timeout} 
		[left]:action 
		[right]:action 
		[timeoutExpression]:exp
	| {hiding} 
		[left]:action 
		[chansetExpression]:exp
	| {startDeadline} 
		[left]:action 
		[expression]:exp
	| {endDeadline} 
		[left]:action 
		[expression]:exp
	| {channelRenaming} 
		[action]:action 
		[renameExpression]:exp.#Channel.#Rename
    | {mu} 
    	[identifiers]:LexIdentifierToken* 
    	[actions]:action*
    | #Parallel
	| {parametrised} 
		[parametrisations]:parametrisation* 
		[action]:action 
	| #Instantiated
	| #Replicated
	| #Statement
	| {call} 
		[actionName]:LexNameToken
	| {subclassResponsibility}
	| {reference} [name]:LexNameToken
	;
	
#Parallel {-> package='eu.compassresearch.ast.actions'}
	= {interleaving} 
	| {generalisedParallelism} 
		[chanSetExpression]:exp
	| {alphabetisedParallelism}
		[leftChanSetExpression]:exp 
		[rightChanSetExpression]:exp
	| {synchronousParallelism}
	;	

#Replicated {-> package='eu.compassresearch.ast.actions'}
	= {sequentialComposition}  
	| {externalChoice}
	| {internalChoice}
	| {interleaving} 
		[nameSetExpression]:exp
	| {generalisedParallelism} 
		[chansetExpression]:exp
		[nameSetExpression]:exp
	| {alphabetisedParallelism}
		[nameSetExpression]:exp 
		[chansetExpression]:exp
	| {synchronousParallelism}
		[nameSetExpression]:exp
	;	
	
#Instantiated {-> package='eu.compassresearch.ast.actions'}
	= {declaration} [declaration]:declaration.#Single.type* [action]:action [args]:exp*
	| {parametrised} [action]:action.parametrised  [args]:exp*
	;
	
communicationParameter {-> package='eu.compassresearch.ast.actions'}
	= {read} [expression]:exp
	| {write}  
	| {signal} 	
	;
	
parametrisation {-> package='eu.compassresearch.ast.actions'}
	= {val}	
	| {res} 
	| {vres} 
	;
//These are now patterns instead
//parameter {-> package='eu.compassresearch.ast.actions'}
//	= {identifier} [identifier]:LexIdentifierToken
//	| {tuple} [parameters]:parameter*
//	| {record}	[name]:LexNameToken [parameters]:parameter* 
//	;

#Statement {-> package='eu.compassresearch.ast.actions'}
	= {let} [action]:action [localDefinitions]:definition*
	| {block} [declareStatement]:action.#Statement.declare [action]:action	
	| {nonDeterministicIf} 
		[alternatives]:action.#Statement.nonDeterministicAlt*
	| {nonDeterministicAlt} 
		[guard]:exp 
		[action]:action
	| {if} 
		[ifExp]:exp 
		[thenStm]:action 
		[elseIf]:action.#Statement.elseIf* 
		[elseStm]:action
	| {elseIf} 
		[elseIf]:exp 
		[thenStm]:action
	| {cases} 
		[exp]:exp 
		[cases]:alternativeAction.case* 
		[others]:action
	| #GeneralAssignment
	| {call} 
		[objectDesignator]:objectDesignator 
		[name]:LexNameToken 
		[args]:exp*
	| {specification} 
		[externals]:clause.external* 
		[precondition]:exp 
		[postcondition]:exp 
	| {assignmentCall} 
		[designator]:stateDesignator 
		[call]:action.#Statement.call
	| {return} 
		[exp]:exp
    | {notYetSpecified} 
		[opname]:LexNameToken 
		[args]:exp*
	| {new} 
		[destination]:stateDesignator 
		[className]:LexNameToken 
		[args]:exp* 
		(classdef):definition.#paragraph.class 
		(ctorDefinition):definition
	| {nonDeterministicDo} 
		[alternatives]:action.#Statement.nonDeterministicAlt*
	| {forSet} 
		[pattern]:pattern 
		[set]:exp 
		[action]:action
    | {forIndex} 
    	[var]:LexNameToken 
    	[from]:exp 
    	[to]:exp 
    	[by]:exp 
    	[action]:action
    | {forSequence} 
    	[patternBind]:patternBind.def 
    	//[reverse]:java_Boolean 
    	[exp]:exp 
    	[action]:action 
    	(seqType):type.#seq
    | {while} 
    	[condition]:exp 
    	[action]:action 
	| {declare}  [assignmentDefs]:definition*
	;

#GeneralAssignment {-> package='eu.compassresearch.ast.actions'}
    = {single} [stateDesignator]:stateDesignator [expression]:exp
    | {multiple} [assignments]:action.#Statement.#GeneralAssignment.single*
	;

objectDesignator {-> package='eu.compassresearch.ast.actions'}
	= {unresolved} [identifiers]:LexIdentifierToken* 
	;
	
stateDesignator {-> package='eu.compassresearch.ast.actions'}
    =   {unresolved} [identifiers]:LexIdentifierToken*
    ;

alternativeAction {-> package='eu.compassresearch.ast.actions'}
    = {case} [location]:location [pattern]:pattern* [result]:action (defs):definition* 
    ;
Aspect Declaration
/* This section allows fields of root types to be declared e.g. exp*/
	
%action =  [location]:location
	;
	
%exp = (isVisited):java_Boolean
     ;
	
%action->#Replicated = [replicationDeclaration]:declaration.#Single* [replicatedAction]:action 
	;
	
%action->#Parallel = 	[leftAction]:action
						[leftNameSetExpression]:exp 
						[rightNameSetExpression]:exp
						[rightAction]:action
	;	

%action->#Statement = (type):type
    ;

%communicationParameter = [location]:location [pattern]:pattern
	; 

%declaration =  [location]:location [nameScope]:nameScope
	;
    
%parametrisation = [location]:location [declaration]:declaration.#Single.type 
	;

%process =  [location]:location 
	;

%process->#Replicated = [replicationDeclaration]:declaration.#Single* [replicatedProcess]:process 
	;

%parameter = [location]:location
	; 

%source = [paragraphs]: definition.#paragraph*
	;