//TODO1: maybe generate classes with the Comparable interface 
Packages
base eu.compassresearch.ast.node;
analysis eu.compassresearch.ast.analysis;

Tokens
  java_File = 'java:java.io.File';
  java_Stream = 'java:java.io.InputStream';


Abstract Syntax Tree

source {->  package='eu.compassresearch.ast.program'}
      = {file} [name]: java_String (file): java_File
      | {tcpStream} [ip]: java_String [port]: java_String (stream): java_Stream 
      | {inputStream} [origin]: java_String (stream): java_Stream
      ;

/*
 Declarations 
*/
singleDeclaration {-> package='eu.compassresearch.ast.declarations'}
	= {type}  
    	[identifiers]:LexIdentifierToken* 
    	(type):type
	| {expression}
    	[identifiers]:LexIdentifierToken* 
    	[expression]:exp
    ;
/*
 Definitions 
*/
definition {-> package='eu.compassresearch.ast.definitions'}
    =   {action} 
    		[declarations]:singleDeclaration.type* 
    		[action]:action
    |   {chanset} 
    		[identifier]:LexIdentifierToken 
    		[chansetExpressions]:exp
    |   #operation    
    |   {process}
    		[localState]: singleDeclaration*
	     	[process]: process
    | {channelName} 
    	[singleType]: singleDeclaration.type
    | {class}
   	[body]: definition*
       	[hasContructors]:java_Boolean
	[gettingInheritable]:java_Boolean
	[isAbstract]:java_Boolean
	[isUndefined]:java_Boolean
	(classtype):type
	(isTypeChecked):java_Boolean
	(invariant):definition.#operation.explicit
   	(supertypes):type* 
	(superDefs):definition*	
   | {channels} 
	[channelNameDeclarations]: definition.channelName*
   | {chansets} 
     	[chansets] : definition.chanset*
   | {actions} 
	[actions]: definition.action*
  | {types} 
        [types]: definition.type*
   | {operations} 
	[operations]:definition.#operation*
   | {function} 
	[functionDefinitions]:definition*
   | {values} 
	[valueDefinitions]: definition*
   | {initial} 
	[operationDefinition]: definition
   | {states} 
	[fields]:field.field* 
        [invPattern]:pattern [invExpression]:exp (invdef):definition.explicitFunction
        [initPattern]:pattern [initExpression]:exp (initdef):definition.explicitFunction
        (stateDefs):definition* 
   ;

/*
 * Operations 
 *
 */
#operation {-> package='eu.compassresearch.ast.definitions'}
	=   {explicit} 	[parameterPatterns]:pattern* 
                        [body]:action
                        [isConstructor]:java_Boolean
                        (type):type.operation
                        (predef):definition.explicitFunction
                        (postdef):definition.explicitFunction
                        (paramDefinitions):definition*
                        (state):definition.states
                        (actualResult):type
                            
    |   {implicit}      [parameterPatterns]:pair.patternListType*
                        [result]:pair.patternType*
                        [externals]:clause.external*
                        [precondition]:exp 
                        [postcondition]:exp
                        [isConstructor]:java_Boolean    
                        [errors]:case.error*
                        (type):type.operation
                        (predef):definition.explicitFunction
                        (postdef):definition.explicitFunction
                        (state):definition.states
                        (actualResult):type
                        (stateDefinition):definition
    ;

/*
    Expressions
*/    
exp {-> package='eu.compassresearch.ast.expressions'}
    =   {bracketed} [expression]:exp /*cml*/
    |   {stateInit} (state):definition.states  
    |   {tupleSelect} [tuple]:exp [entry]:java_Integer 
    |   #Channel
    | 	{unresolvedPath} [identifiers]:LexIdentifierToken*
    ;
    
#Channel  {-> package='eu.compassresearch.ast.expressions'}
	= #Rename
	| {name} 	[identifier]:LexNameToken 
				[dottedPatternList]:pattern* //This use to be expressions!
	;
	
#Rename   {-> package='eu.compassresearch.ast.expressions'}
 	= {comprehension} [renamePairs]:pair.rename [bindings]:multipleBind* [predicate]:exp
 	| {enumeration} [renamePairs]:pair.rename*
    ;
    
ChansetExpression {-> package='eu.compassresearch.ast.expressions'}
	= {identifier} [identifier]:LexIdentifierToken
	| {enum} [identifiers]:LexIdentifierToken*
	| {comp} [channelNameExp]:exp.#Channel.name [bindings]:multipleBind* [predicate]:exp 
	| {Union} [left]:ChansetExp [op]: LexToken [right]:ChansetExp
	| {Inter} [left]:ChansetExp [op]: LexToken [right]:ChansetExp
	| {Sub}   [left]:ChansetExp [op]: LexToken [right]:ChansetExp
    	;

NamesetExpression {-> package='eu.compassresearch.ast.expressions'}
	= {identifier} [identifier]:LexIdentifierToken
	| {enum} [identifiers]:LexIdentifierToken*
	| {comp} [channelNameExp]:exp.#Channel.name [bindings]:multipleBind* [predicate]:exp 
	| {Union} [left]:NamesetExp [op]: LexToken [right]:NamesetExp
	| {Inter} [left]:NamesetExp [op]: LexToken [right]:NamesetExp
	| {Sub}   [left]:NamesetExp [op]: LexToken [right]:NamesetExp
	;


/* 
	Types 
*/

type {-> package='eu.compassresearch.ast.types'}
    =   {statement} // marker that a statement is typed ok
    |   {process} // marker that a process is typed ok
    |   {error} // marker that type of a subtree has failed 
    |   {processParagraph} // marker stipulating process paragraph is typed ok
    |   {chansetParagraph} // marker stipulating a chanset paragraph is typed ok
    |   {channelsParagraph} // marker stipulating a chanset paragraph is typed ok
    |   {actionParagraph} // marker stipulating that a Action Paragraph is typed ok
    |   {valueParagraph} // marker stipulating that a Values paragraph is typed ok
    |   {functionParagraph} // marker stipulating that a Function Paragraph is typed ok
    |   {typeParagraph} // marker stipulating that a Types Paragraph is typed ok
    |   {operationParagraph} // marker stipulating that a Function Paragraph is typed ok
    |   {stateParagraph} // marker stipulating that a state Paragraph is typed ok
    |   {source} // marker stipulating a source was typed ok
    |   {channel} (type):type // marker stipulating that a channel Paragraph is typed ok
    |   {initialParagraph} // marker
    |   {action} // marker 
    ; 

access  {-> package='eu.compassresearch.ast.definitions'}
    =   {logical}
    ;

/* 
	Patterns 
*/
    
pair {-> package='eu.compassresearch.ast.patterns'}
    = {rename} [from]:exp.#Channel.name [to]:exp.#Channel.name
    ; 

/*
	Process
*/
process {-> package='eu.compassresearch.ast.process'}
	= {action} 
		[definitionParagraphs]:definition* 
		[action]:action
	| {sequentialComposition} 
		[left]:process 
		[right]:process
	| {externalChoice} 
		[left]:process 
		[right]:process
	| {internalChoice} 
		[left]:process 
		[right]:process
	| {generalisedParallelism} 
		[left]:process 
		[chansetExpression]:exp 
		[right]:process
	| {alphabetisedParallelism} 
		[left]:process 
		[leftChansetExpression]:exp 
		[rightChansetExpression]:exp 
		[right]:process
	| {synchronousParallelism} 
		[left]:process 
		[right]:process
	| {interleaving} 
		[left]:process 
		[right]:process
	| {interrupt} 
		[left]:process 
		[right]:process
	| {timedInterrupt} 
		[left]:process 
		[timeExpression]:exp 
		[right]:process
	| {untimedTimeout} 
		[left]:process 
		[right]:process
	| {timeout} 
		[left]:process 
		[timeoutExpression]:exp 
		[right]:process
	| {hiding} 
		[left]:process 
		[chansetExpression]:exp
	| {startDeadline} 
		[left]:process 
		[expression]:exp
	| {endDeadline} 
		[left]:process 
		[expression]:exp
	| {instantiation} 
		[declarations]:singleDeclaration.type* 
		[process]: process 
		[args]:exp*
	| {reference}
		[processName]:LexNameToken
		[args]:exp*
		(processDefinition):definition.process
	| {channelRenaming} 
		[process]:process 
		[renameExpression]:exp.#Channel.#Rename
	| #Replicated
	;

#Replicated {-> package='eu.compassresearch.ast.process'}
	= {sequentialComposition}  
	| {externalChoice}
	| {internalChoice}
	| {generalisedParallelism} 
		[chansetExpression]:ChansetExp
	| {alphabetisedParallelism} 
		[chansetExpression]:ChansetExp
	| {synchronousParallelism}
	| {interleaving} 
	;


/* 
	Actions 
*/
action {-> package='eu.compassresearch.ast.actions'}
	= {skip}
	| {stop}
	| {chaos}
	| {div}
	| {wait} 
		[expression]:exp
	| {communication} 
		[identifier]:LexIdentifierToken 
		[communicationParameters]:communicationParameter* 
		[action]:action
	| {guarded} 
		[expression]:exp 
		[action]:action
	| {sequentialComposition} 
		[left]:action 
		[right]:action
	| {externalChoice} 
		[left]:action 
		[right]:action
	| {internalChoice} 
		[left]:action 
		[right]:action
	| {interrupt} 
		[left]:action 
		[right]:action
	| {timedInterrupt} 
		[left]:action 
		[right]:action 
		[timeExpression]:exp
	| {untimedTimeout} 
		[left]:action 
		[right]:action
	| {timeout} 
		[left]:action 
		[right]:action 
		[timeoutExpression]:exp
	| {hiding} 
		[left]:action 
		[chansetExpression]:ChansetExp
	| {startDeadline} 
		[left]:action 
		[expression]:exp
	| {endDeadline} 
		[left]:action 
		[expression]:exp
	| {channelRenaming} 
		[action]:action 
		[renameExpression]:exp.#Channel.#Rename
    | {mu} 
    	[identifiers]:LexIdentifierToken* 
    	[actions]:action*
    | #Parallel
    | {parametrised} 
	[parametrisations]:parametrisation* 
	[action]:action 
    | #Instantiated
    | #Replicated
    | #Statement
   | {subclassResponsibility}
   | {reference} 
	[name]:LexNameToken
	[args]:exp*
	(actionDefinition):definition.action
   ;
	
#Parallel {-> package='eu.compassresearch.ast.actions'}
	= {interleaving} 
	| {generalisedParallelism} 
		[chanSetExpression]:ChansetExp
	| {alphabetisedParallelism}
		[leftChanSetExpression]:ChansetExp
		[rightChanSetExpression]:ChansetExp
	| {synchronousParallelism}
	;	

#Replicated {-> package='eu.compassresearch.ast.actions'}
	= {sequentialComposition}  
	| {externalChoice}
	| {internalChoice}
	| {interleaving} 
		[nameSetExpression]:NamesetExp
	| {generalisedParallelism} 
		[chansetExpression]:ChansetExp
		[nameSetExpression]:NamesetExp
	| {alphabetisedParallelism}
		[nameSetExpression]:NamesetExp 
		[chansetExpression]:ChansetExp
	| {synchronousParallelism}
		[nameSetExpression]:NamesetExp
	;	
	
#Instantiated {-> package='eu.compassresearch.ast.actions'}
	= {declaration} [declaration]:singleDeclaration.type* [action]:action [args]:exp*
	| {parametrised} [action]:action.parametrised  [args]:exp*
	;
	
communicationParameter {-> package='eu.compassresearch.ast.actions'}
	= {read} [expression]:exp
	| {write}  
	| {signal} 	
	;
	
parametrisation {-> package='eu.compassresearch.ast.actions'}
	= {val}	
	| {res} 
	| {vres} 
	;

#Statement {-> package='eu.compassresearch.ast.actions'}
	= {let} [action]:action [localDefinitions]:definition*
	| {block} [declareStatement]:action.#Statement.declare [action]:action	
	| {nonDeterministicIf} 
		[alternatives]:action.#Statement.nonDeterministicAlt*
	| {nonDeterministicAlt} 
		[guard]:exp 
		[action]:action
	| {if} 
		[ifExp]:exp 
		[thenStm]:action 
		[elseIf]:action.#Statement.elseIf* 
		[elseStm]:action
	| {elseIf} 
		[elseIf]:exp 
		[thenStm]:action
	| {cases} 
		[exp]:exp 
		[cases]:alternativeAction.case* 
		[others]:action
	| #GeneralAssignment
	| {specification} 
		[externals]:clause.external* 
		[precondition]:exp 
		[postcondition]:exp 
        | {call} 
		[name]:LexNameToken 
		[args]:exp*
	| {assignmentCall} 
		[designator]:exp 
		[call]:action.#Statement.call
	| {return} 
		[exp]:exp
    | {notYetSpecified} 
		[opname]:LexNameToken 
		[args]:exp*
    | {new} 
	[destination]:exp 
	[className]:LexNameToken 
	[args]:exp* 
	(classdef):definition.class 
	(ctorDefinition):definition
    | {nonDeterministicDo} 
	[alternatives]:action.#Statement.nonDeterministicAlt*
    | {forSet} 
	[pattern]:pattern 
	[set]:exp 
	[action]:action
    | {forIndex} 
    	[var]:LexNameToken 
    	[from]:exp 
    	[to]:exp 
    	[by]:exp 
    	[action]:action
    | {forSequence} 
    	[patternBind]:patternBind.def 
    	[exp]:exp 
    	[action]:action 
    	(seqType):type.#seq
    | {while} 
    	[condition]:exp 
    	[action]:action 
	| {declare}  [assignmentDefs]:definition*
	;

#GeneralAssignment {-> package='eu.compassresearch.ast.actions'}
    = {single} [stateDesignator]:exp [expression]:exp
    | {multiple} [assignments]:action.#Statement.#GeneralAssignment.single*
	;

alternativeAction {-> package='eu.compassresearch.ast.actions'}
    = {case} [location]:location [pattern]:pattern* [result]:action (defs):definition* 
    ;
Aspect Declaration
/* This section allows fields of root types to be declared e.g. exp*/
	
%action =  [location]:location
	;
	
%exp = (isVisited):java_Boolean
     ;
	
%action->#Replicated = [replicationDeclaration]:singleDeclaration* [replicatedAction]:action 
	;
	
%action->#Parallel = 	[leftAction]:action
			[leftNameSetExpression]:NamesetExp
			[rightNameSetExpression]:NamesetExp
			[rightAction]:action
	;	

%action = (type):type
    ;

%communicationParameter = [location]:location [pattern]:pattern
	; 

%singleDeclaration =  [location]:location [nameScope]:nameScope
	;
    
%parametrisation = [location]:location [declaration]:singleDeclaration.type 
	;

%process =  [location]:location 
	;

%process->#Replicated = [replicationDeclaration]:singleDeclaration* [replicatedProcess]:process 
	;

%parameter = [location]:location
	; 

%source = [paragraphs]: definition*
	;