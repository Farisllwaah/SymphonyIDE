types
  NAT = nat
    inv i == i in set {1,...,27}
  INT = int
    inv i == i in set {-2,...,2}
  ID = <fav> | <rv>
  SigID = <End_Recovery_1_S> | <Error_1_detection_S> | <Fault_1_activation_S>
     | <Service_rescue_S> | <Start_Recovery_1_S> | <Start_rescue_S>
     | <Target_not_attended_S>
  OpID = <Allocate_idle_ERU_I> | <Allocate_idle_ERU_O> | <Divert_ERU_I>
     | <Divert_ERU_O> | <Drop_message_I> | <Drop_message_O>
     | <Find_idle_ERUs_I> | <Find_idle_ERUs_O> | <Log_diversion_I>
     | <Log_diversion_O> | <Log_fault_1_I> | <Log_fault_1_O>
     | <Process_message_I> | <Process_message_O> | <Receive_message_MPS_I>
     | <Receive_message_MPS_O> | <Receive_message_RS_I> | <Receive_message_RS_O>
     | <Resend_rescue_info_to_ERU_I> | <Resend_rescue_info_to_ERU_O> | <Send_rescue_info_to_ERU_I>
     | <Send_rescue_info_to_ERU_O> | <Wait_I> | <Wait_O>
channels
  control: NAT
  endDiagram: ID
  interrupted: ID*ID*NAT
  update: NAT*INT
  clear: NAT
  wait, inc, dec
  simultaneous
  fault: ID
  error: ID
  failure: ID

  startActivity_fav: ID
  endActivity_fav: ID
  interruptActivity_fav
  startActivity_rv: ID
  endActivity_rv: ID
  interruptActivity_rv

  sendSignal: SigID
  acceptEvent: SigID
  operation: OpID

chansets
    Hidden_fav = {|
      control, 
      endDiagram, 
      interrupted, 
      update, 
      clear, 
      wait, 
      inc, 
      dec, 
      interruptActivity_fav
    |}
    Hidden_rv = {|
      control, 
      endDiagram, 
      interrupted, 
      update, 
      clear, 
      wait, 
      inc, 
      dec, 
      interruptActivity_rv
    |}
 
process ad_internal_Recovery_1 = val Fault_1_id_2: ID @ begin
  state
    nToken_1: nat := 0
  actions
    START_ACTIVITY_1 = startActivity_rv.Fault_1_id_2 -> Skip   --      atomic -> ()
    END_DIAGRAM_1 = endDiagram.<rv> -> Skip
    CNode_1_2 = (update.1!1 -> (control!1 -> Skip); wait -> Skip)
      /_\ END_DIAGRAM_1
    Start_Recovery_1_2 = (dcl end_guard_1_2: bool := true @
      (
      (control.1 -> Skip);
      (acceptEvent.<Start_Recovery_1_S> -> Skip);
      (control.2 -> Skip);Start_Recovery_1_2)
      /_\ [end_guard_1_2] & END_DIAGRAM_1)
    Log_fault_1_3 = (dcl end_guard_1_3: bool := true @
      (
      (control.2 -> Skip);
      (operation.<Log_fault_1_I> -> inc -> end_guard_1_3 := false;
      operation.<Log_fault_1_O> -> dec -> end_guard_1_3 := true);
      (control.3 -> Skip);Log_fault_1_3)
      /_\ [end_guard_1_3] & END_DIAGRAM_1)
    Resend_rescue_info_to_ERU_4 = (dcl end_guard_2_4: bool := true @
      (
      (control.3 -> Skip);
      (operation.<Resend_rescue_info_to_ERU_I> -> inc -> end_guard_2_4 := false;
      operation.<Resend_rescue_info_to_ERU_O> -> dec -> end_guard_2_4 := true);
      (control.4 -> Skip);Resend_rescue_info_to_ERU_4)
      /_\ [end_guard_2_4] & END_DIAGRAM_1)
    Process_message_5 = (dcl end_guard_2_5: bool := true @ 
      (
      (control.4 -> Skip);
      (operation.<Process_message_I> -> inc -> end_guard_2_5 := false;
      operation.<Process_message_O> -> dec -> end_guard_2_5 := true);
      (control.5 -> Skip);Process_message_5)
      /_\ [end_guard_2_5] & END_DIAGRAM_1)
     Receive_message_MPS_6 = (dcl end_guard_2_6: bool := true @
      (
      (control.5 -> Skip);
      (operation.<Receive_message_MPS_I> -> inc -> end_guard_2_6 := false;
      operation.<Receive_message_MPS_O> -> dec -> end_guard_2_6 := true);
      (control.6 -> Skip);Receive_message_MPS_6)
      /_\ [end_guard_2_6] & END_DIAGRAM_1)
    End_Recovery_1_7 = (dcl end_guard_1_7: bool := true @
      (
      (control.6 -> Skip);
      (sendSignal.<End_Recovery_1_S> -> Skip);
      (control.7 -> Skip);End_Recovery_1_7)
      /_\ [end_guard_1_7] & END_DIAGRAM_1)
    CNode_8 = (control.7 -> clear.8 -> wait -> Skip)
      /_\ END_DIAGRAM_1
    Nodes_2 =
      ((((((CNode_1_2 [| {| endDiagram.<rv>, control.1 |} |] Start_Recovery_1_2)
      [| {| endDiagram.<rv>, control.2 |} |] Log_fault_1_3)
      [| {| endDiagram.<rv>, control.3 |} |] Resend_rescue_info_to_ERU_4)
      [| {| endDiagram.<rv>, control.4 |} |] Process_message_5)
      [| {| endDiagram.<rv>, control.5 |} |] Receive_message_MPS_6)
      [| {| endDiagram.<rv>, control.6 |} |] End_Recovery_1_7)
      [| {| control.7, endDiagram.<rv> |} |] CNode_8
    TOKEN_MANAGER_2 = update?o?x -> STARTED_TOKEN_MANAGER_2(x)
    STARTED_TOKEN_MANAGER_2 = val nTokens_2 : INT @ (
    update?o2?x2 -> nTokens_2 := nTokens_2 + x2; STARTED_TOKEN_MANAGER_2(nTokens_2)
    []
    clear?o2 -> nTokens_2 := 0; endDiagram.<rv> -> Skip)
    []
    [nTokens_2 = 0] & endDiagram.<rv> -> Skip
    INT_ACT_MANAGER_2 = STARTED_INT_ACT_MANAGER_2(0)
    STARTED_INT_ACT_MANAGER_2 = val i_2: NAT @ (
    inc -> i_2 := i_2 + 1; STARTED_INT_ACT_MANAGER_2(i_2)
    []
    dec -> i_2 := i_2 - 1; STARTED_INT_ACT_MANAGER_2(i_2)
    []
    [i_2 = 0] & interruptActivity_rv -> Skip)
    MAIN_2 =  ((
    (START_ACTIVITY_1; ((Nodes_2 [| {|update, clear, wait, endDiagram |} |] TOKEN_MANAGER_2));
      endActivity_rv.Fault_1_id_2 -> Skip); MAIN_2) /_\ interruptActivity_rv -> MAIN_2) [| {| inc, dec, interruptActivity_rv|} |] INT_ACT_MANAGER_2 \\ Hidden_rv
    @ MAIN_2
end

-- process ad_Recovery_1 = ad_internal_Recovery_1(<rv>)

process SIGNAL_BUFFER =
begin
  actions
    SS_UNIT = val idSS : SigID @ sendSignal.idSS -> SS_UNIT(idSS)
    FULL_UNIT = val idF : SigID @ sendSignal.idF -> acceptEvent.idF -> FULL_UNIT(idF)
    AE_UNIT = val idAE : SigID @ acceptEvent.idAE -> AE_UNIT(idAE)
    FULL = FULL_UNIT(<Start_rescue_S>) ||| FULL_UNIT(<Start_Recovery_1_S>) ||| FULL_UNIT(<End_Recovery_1_S>)
    AE =  AE_UNIT(<Fault_1_activation_S>) |||  AE_UNIT(<Error_1_detection_S>) 
    SS = SS_UNIT(<Fault_1_activation_S>) ||| SS_UNIT(<Error_1_detection_S>)  
  @ FULL_UNIT(<Start_rescue_S>) ||| FULL_UNIT(<Start_Recovery_1_S>) ||| FULL_UNIT(<End_Recovery_1_S>) ||| AE_UNIT(<Fault_1_activation_S>) |||  AE_UNIT(<Error_1_detection_S>) ||| SS_UNIT(<Fault_1_activation_S>) ||| SS_UNIT(<Error_1_detection_S>)
  
  -- for some reason, FORMULA raises an error when we use FULL ||| AE ||| SS  
end