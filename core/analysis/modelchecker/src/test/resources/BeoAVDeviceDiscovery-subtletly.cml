  types
    Device_Record = nat -- uniq device ID
      -- inv i == i in set {1,...,3}
    ServiceCallData = nat  -- abstation for the service call data structure being sent over the network
      inv i == i in set {1,...,3}
    DeviceEvent = (<INTERUPT>|<POWER_ON>|<POWER_OFF>) -- user device event
    TCP_PortEvent = (<CONNECT>|<DISCONNECT>) -- IP TCP events using for adding IP connect/disconnect logic to channels

  values
    timeout : nat = 1 -- generic IP timeout
    sourceBroadcastTime : nat = 2 -- timeouts for the source product
    targetBroadcastTime : nat = 2 -- timout for the targte product  these values can be used for playing with the wait time for the processes
    ServiceCallDataERROR:ServiceCallData = 0  -- error return value to the application layer
  
  functions
   IsDeviceInSet:Device_Record * set of Device_Record -> bool -- helper function 
   IsDeviceInSet(d, s)== d in set s
   --this function means a simple membership test. It was modified because its body was "d not in set s". All negated funcion calls in the specification were also changed
  
  channels 
--- channels for the DD and SD part of the SoS
    IPMulticastChannel:Device_Record
    SourceProductPowerChannel:DeviceEvent
    TargetProductPowerChannel:DeviceEvent

--- channels for the service part of the SoS
   SourceProductEventChannel:DeviceEvent
   TargetProductEventChannel:DeviceEvent
   BrowsingInterfaceCallChannel:ServiceCallData
   BrowsingInterfaceReplyChannel:ServiceCallData
   IPTCPChannel:ServiceCallData
   IPTCPPORTChannel:TCP_PortEvent
   LocalInterfaceChannel:ServiceCallData
  
-- CML process modelling the B&O DD protocol for the source product in the network
  process SourceProduct_DD_SD_InterfaceProtocolView =
  begin
	  state
         product_DR:Device_Record := 2 -- local device id              
      operations      
         createDDSDObject :()==>() --update the data with service status info, needs to be done before each broadcast
         createDDSDObject()== product_DR := 2 -- just simulate updating the device record
	  --actions	  
	--	Off_State = SourceProductPowerChannel.<POWER_ON> -> On_State -- product can be powered on by a user event
	--	On_State = DD_SD_Announcement_State /_\ (SourceProductPowerChannel.<POWER_OFF>->Off_State)  -- the Announcement loop can be interupted by a user event 
	--	DD_SD_Announcement_State = (MarshallData_State; Wait(sourceBroadcastTime);  DD_SD_Announcement_State) -- Announce the device in the network using multicast
	 -- 	MarshallData_State = (createDDSDObject();IPMulticastChannel!product_DR -> Skip) [_ timeout _> (Skip) --- simulate IP multicast logic using timeouts
      @ IPMulticastChannel?x -> Skip
  end
	
  
  