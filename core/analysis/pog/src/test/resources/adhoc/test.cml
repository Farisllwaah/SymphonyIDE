--
-- BeDOZa Ideal Model
--
-- Author: Rasmus Lauritsen, Aarhus University
-- Created: 2013 Feb
--
--
-- Purpose: 
--
-- The purpose of this model is to get a view of how ideal  
-- version of the BeDOZa can be modelled in CML_1. 
-- 
--
-- This is work carried out in the European FP 7 Project 
-- COMPASS grant 287829.
-- 
types
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  -- Type Value
  --  
  -- The Value type is used for values in the underlying 
  -- field.
  --
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  Value = int
  
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  -- Type ValueID
  -- 
  -- The ValueID type is for refering to a the 
  -- representation of a shared value.
  --
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
    ValueID = nat
    
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  -- Type PartyID
  --
  -- Every party has a unique ID of type PartyID 
  -- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  PartyID = nat

  --
  -- An Add instruction for the MPC protocol
  -- [*] id1 is the id for the left operand to add
  -- [*] id2 is the id for the second operand to add
  -- [*] rid is the id for the result of the add operation
  --
  Add :: 
          id1 : ValueID
          id2 : ValueID
          rid : ValueID
    inv add == 
        add.id1 <> add.id2 and 
        add.id1 <> add.rid and 
        add.id2 <> add.rid
    --
    -- A Multiplication instruction for the MPC protocol
    -- [*] id1 is the id for the left operand 
    -- [*] id2 is the id for the right operand
    -- [*] rid is the id for the result
    --
    Mul ::
            id1 : ValueID
            id2 : ValueID
            rid : ValueID
    inv mul ==  
        mul.id1 <> mul.id2 and 
        mul.id1 <> mul.rid and 
        mul.id2 <> mul.rid
    --
    -- A Minimum instruction for the MPC protocol
    -- [*] id1 is the left operand  
    -- [*] id2 is the right operand 
    -- [*] rid is the id for the result  
    --
    Min ::
            id1 : ValueID
            id2 : ValueID
            rid : ValueID
    inv min == 
            min.id1 <> min.id2 and 
            min.id1 <> min.rid and 
            min.id2 <> min.rid
    
    --
    -- An input instruction inputs a value to the circuit 
    -- [*] is the id the inputted value shall have
    -- [*] pid is the party inputting the value 
    --
    Inp ::
            vid : ValueID
            pid : PartyID
    
    --
    -- Open a value as output to a party 
    -- [*] id is the id of the value to output
    -- [*] party is the PartyID of the 
    --
    Out ::
            id : ValueID
            party: PartyID
            
    --
    -- An MPC circuit consists of any combination of the 
    -- above instructions.  
    --
    MpcInstructionSet = Add | Mul | Min | <Abort> | <Stop>
    
    --
    -- An MPC circuit is defined to be a sequence of 
    -- MpcInstructionSet 
    --
    Circuit =  seq of MpcInstructionSet


channels
  input: PartyID * Value
  output: PartyID  * Value

-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
-- Process AMPC for ONLINE BeDOZa
--
--  circuit  : circuit     - the circuit to compute
--  
-- This process is the ideal functionality for AMPC 
-- it is initialised with the circuit to compute.
-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
process AMPC = 
  val circuit : Circuit 
@
  begin
    state
      memory       : map ValueID to Value
      mycircuit    : Circuit := circuit
      
    operations
     NextInstr: () ==> MpcInstructionSet
     NextInstr() == 
     (dcl result : MpcInstructionSet := hd mycircuit @
       mycircuit := tl mycircuit ; 
       return result)
     
    actions
      Ready =
      if (len(mycircuit) = 0)
      then Skip 
      else 
      (dcl
        curinstr : MpcInstructionSet := NextInstr()
      @
        cases curinstr :  
         mk_Inp(pid,vid) -> 
           input!pid?v -> 
             memory(vid) := v ; Ready, 
         mk_Out(pid,vid) -> 
           output!pid!(memory(vid)) -> 
             Skip,
         mk_Add(vid1,vid2,vid3) ->
           (dcl
             v1 : Value := memory(vid1),
             v2 : Value := memory(vid2)
           @
             memory(vid3) := v1 + v2
           ) ; Ready, 
         mk_Mul(vid1,vid2,vid3) ->
           (dcl
             v1 : Value := memory(vid1),
             v2 : Value := memory(vid2)
           @
             memory(vid3) := v1 * v2
           ) ; Ready,
         mk_Min(vid1,vid2,vid3) ->
           (dcl
             v1 : Value := memory(vid1),
             v2 : Value := memory(vid2)
           @
             if (v1 < v2) 
             then 
               memory(vid3) := v1
             else
               memory(vid3) := v2
           ) ; Ready,
          others -> Stop
        end
      )
  @
    Ready
end

-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
-- Process Party for ONLINE BeDOZa
--
--  partyID   : PartyID      - the id this Party shall have 
--  inputs    : seq of Value - private inputs for this party
--  nooutputs : int          - number of expected output before
--                             successful termination.
-- 
-- The Party process participates in given its inpus to 
-- the ideal AMPC functionality and in receiving output
-- from the AMPC. 
-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
process Party = 
    val partyID     : PartyID, 
    val inputs      : seq of Value,
    val nooutputs   : int
@
  begin
    state
      myinputs : seq of Value := inputs
      mynoo    : int := nooutputs
    operations
      
      NextInput: () ==> Value
      NextInput() == 
      (dcl 
        result : Value := hd myinputs 
      @
        myinputs := tl myinputs
      )
       
    actions 
        GiveInput  = if (len(myinputs) = 0)
                    then Skip
                    else (input?myid!(NextInput()) -> GiveInput)
                    
        TakeOutput = if (nooutputs - mynoo = 0) 
                     then Skip
                     else ( mynoo := mynoo + 1 ; TakeOutput ) 
        Done = Skip
    @ GiveInput ; TakeOutput ; Done
  end
  
  
values
    -- ~-~-~-~-~-~-~-~-~-~-~-~-~-~~-~-~-~-~-~-~-~-~-~-~
    -- SCENARIO: Three party double auction
    --
    -- Prices = [ 10, 20, 30 ]
    -- 
    -- Mnemomic   |        Bids         | PartyID  
    -- Buyer   =  [  8,  4,  2 ]          0
    -- Seller1 =  [  3,  5,  6 ]          1
    -- Seller2 =  [  0,  1,  10]          2
    -- Seller3 =  [  2,  4,   8]          3
    --
    -- Deffic =   [ -3,  6,  22] 
    --
    -- The expected clearing price for the double auction 
    -- above is 10 as the absolute of the Deficiency of 
    -- the market is lowest at that price.     
    --
    ThreePartyDoubleAuction: Circuit =
    [  
        mk_Inp( 0,0), -- Party 0 inputs value at id 0
        mk_Inp( 1,0), -- Party 0 inputs value at id 1
        mk_Inp( 2,0), -- Party 0 inputs value at id 2
        mk_Inp( 3,1), -- Party 1 inputs value at id 3
        mk_Inp( 4,1), -- Party 1 inputs value at id 4
        mk_Inp( 5,1), -- Party 1 inputs value at id 5
        mk_Inp( 6,2), -- Party 2 inputs value at id 6
        mk_Inp( 7,2), -- Party 2 inputs value at id 7
        mk_Inp( 8,2), -- Party 2 inputs value at id 8
        mk_Inp( 9,3), -- Party 3 inputs value at id 9
        mk_Inp(10,3), -- Party 3 inputs value at id 10
        mk_Inp(11,3), -- Party 3 inputs value at id 11
        
        -- Compute the total supply for price 10:
        mk_Add(3,6,12),-- Add Seller1 bid at price 10
                       -- with Seller2 bid at price 10
                       -- store the result with id 12
                                   
        mk_Add(12,9,13),-- Add Seller3 bid at price 10
                        -- to the sum above and store
                        -- the result with id 13
        -- Total supply is store in 13 for price 10
        
        -- Compute the total supply for price 20:
        mk_Add(4,7,14),
        mk_Add(14,10,15),
        -- Total supply is stored in 15 for price 20
        
        -- Compute the total supply for price 20:
        mk_Add(5,8,16),
        mk_Add(16,11,17),
        -- Total supply is stored in 17 for price 30
        
        -- Compute the total Demand at each price
        -- is alread done as there is only one buyer.
        
        -- Compute difference between supply and demand
        -- we assume as for the AMPC and Single System
        -- models that demand is given as negative 
        -- numbers and demand is given as positive
        -- numbers.
        mk_Add(13,0,20), 
        mk_Add(15,1,21),
        mk_Add(17,2,22),
         -- Compute the min value in 20,21,22 and
        -- store the result in 24 using 23 as inter-
        -- mediate result.
        mk_Min(20,21,23),
        mk_Min(23,22,24),
        
        -- Everybody learns the output
        mk_Out(24,0), 
        mk_Out(24,1), 
        mk_Out(24,2),
        mk_Out(24,3)
     ]                 
-- ~-~-~-~-~-~-~-~-~-~-~-~-~-~~-~-~-~-~-~-~-~-~-~-~
-- Instantiate participating processes
-- ~-~-~-~-~-~-~-~-~-~-~-~-~-~~-~-~-~-~-~-~-~-~-~-~     
process IdealF  = AMPC(ThreePartyDoubleAuction)

values 
 inputs : seq of (seq of int) = [ [-8,-4, -2],[3,5,6],
                                  [0,1,10],[2,4,8] ]
                                  
process Auction = ||| k in set {0,1,2,3} @ 
                    ( Party(k,inputs(k),1) 
                        [| {| input.i | i in set {k} |} union 
                           {| output.i | i in set {k} |} |]  
                      IdealF
                    )
                  
                    