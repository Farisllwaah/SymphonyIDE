---------------------------------------------
-- Model of cars in a city				   --
-- Authors: RJP and JWB.				   --
-- Version 0.1							   --
---------------------------------------------

types
-- We define a general directed graph of Nodes and Edges

	NodeId = token
	
	EdgeId = token
	
	Node = token -- The intention is to replace this with the Junction model
	
	-- An Edge links Nodes. An Edge has direction.
	-- An Edge could have capacity (not included in this version)
	   
	Edge :: frNode : NodeId
			toNode : NodeId
			
	-- Distinct Node identifiers are mapped to distinct Nodes	 	
	Nodes = inmap NodeId to Node
	-- inv n == forall n1, n2 in set dom n @ n1<>n2 => n(n1) <> n(n2)
		
	Edges = inmap EdgeId to Edge
	--inv e == forall e1, e2 in set dom e @ 
	--			e1 <> e2 => e(e1).fromNode <>  e(e2).fromNode
	--						or
	--						e(e1).toNode <>  e(e2).toNode							
									
process City = n : Nodes, e: Edges @
begin

state

-- A city network is a directed graph, with the additional restriction that there is a path between every Node.
-- The existsPath operation is defined above. 

	nodes : Nodes
	edges : Edges

operations

	private nextEdges : NodeId ==> set of Edge
	nextEdges(n) == 
		return {e1 | e1 in set rng edges @ e1.frNode = n}
	pre n in set dom nodes -- any others?
	
	private existsPath : NodeId * NodeId * set of NodeId ==> bool 
	existsPath(nId1, nId2, visited)	== 
	(
		dcl possEdges  : set of Edge :=  nextEdges(nId1),
		 notVisited : set of Edge := {} @ -- {e | e in set possEdges @ e.toNode not in set visited} @ --TYPECHECKER/PARSER DID NOT SPOT TYPO IN VAR NAME (VISITED) 
	   ( -- possEdges  := nextEdges(nId1);
		notVisited := {e1 | e1 in set possEdges @ e1.toNode not in set visited} ;
		if exists pe in set possEdges @ pe.frNode = nId1 and pe.toNode = nId2
		then return true
		elseif notVisited = {}
			then return false
			else for all edge in set notVisited 
				 do existsPath(edge.toNode, nId2, visited union {nId1})
	   )
	)
	pre nId1 in set dom nodes and 
	    nId2 in set dom nodes -- are there any more?
		
state

	inv forall nId1, nId2 in set dom nodes @ nId1 <> nId2 => existsPath(nId1,nId2,{})
  
operations
	
	private Init : Nodes * Edges ==> ()
	Init(n, e) ==
	(
		nodes := n;
		edges := e
	)
-- In this version, the city has no behaviour.
	
	@ Init(n, e)
	
end

-- A car is initialised by giving it a route
-- The car does not have a location before it gets a route (The initialisation operation gives a car a route)
-- After the car is initialised the location is the first point on the route.
-- The car does not currently check that it receives a valid route.

process Car = r : seq of EdgeId @
begin

state 

	route : seq of EdgeId  
	loc : nat
	-- A route is economical: it must not traverse the same Edge twice.
	-- Further, it has no cycles.  We can make this restriction because all routes through a Node are valid.  
	-- A car therefore has no reason to revisit a node.
	-- Later, we will restrict the set of valid routes through a junction, and have to remove this invariant.
	inv loc <= len route -- A car cannot leave its route. 
	    -- card elems route = len route and 
		-- no cycles.  -- a car must not enter a Node twice.
		-- this subsumes the first conjunct.
		-- and card {route(i)   .toNode | i in set 1..len route} = len route
	
operations

	private Init : seq of EdgeId ==> ()
	Init(eseq) ==
	(
		route := eseq;
		loc := 1
	)
	
	private AtDest: () ==> bool
	AtDest() ==
		return loc = len route
		
    private Move : () ==> ()
	Move() ==
		loc := loc + 1
	pre not AtDest()
	post loc = loc~ + 1
			
actions
	
	Stopped = Skip
	
	Driving = [not AtDest()] & Move();Driving
			  []
			  [AtDest()] & Stopped
			  
@ Init(r); Driving

end

-- There is no communication between Cars and TestCity

process World = Cars ||| TestCity 

-- There is no communication between Cars
---                       TestRoutes RWL RC: TestRoutes does not exists
process Cars = ||| r in set {} @ Car(r)

process TestCity = City(TestNodesEmpty,TestEdgesEmpty)

values 
   TestNodesEmpty : Nodes = {|->}
   TestEdgesEmpty : Edges = {|->}
   TestRoutesEmpty : set of seq of Edges = {} 
   
   n1 :NodeId  = mk_token("n1")
   n2 :NodeId  = mk_token("n2")
   n3 :NodeId  = mk_token("n3")
   n4 :NodeId  = mk_token("n4")
   n5 :NodeId  = mk_token("n5")
  
   node1: Node = mk_token("node1")
   node2: Node = mk_token("node2")
   node3: Node = mk_token("node3")
   node4: Node = mk_token("node4")
   node5: Node = mk_token("node5")
   
   allnodes :Nodes = {n1|->node1, n2|->node2, n3|->node3, n4|->node4, n5|->node5}
   
   e12 :EdgeId  = mk_token("e12")
   e21 :EdgeId  = mk_token("e21")
   e23 :EdgeId  = mk_token("e23")
   e31 :EdgeId  = mk_token("e31")
   e34 :EdgeId  = mk_token("e34")
   e45 :EdgeId  = mk_token("e45")
   
   edge12 :Edge = mk_Edge(n1, n2) 
   edge21 :Edge = mk_Edge(n2, n1) 
   edge23 :Edge = mk_Edge(n2, n3) 
   edge31 :Edge = mk_Edge(n3, n1) 
   edge34 :Edge = mk_Edge(n3, n4) 
   edge45 :Edge = mk_Edge(n4, n5) 
   
   alledges :Edges = {e12|->edge12, e21 |->edge21, e23|->edge23, e31|->edge31, e34|->edge34, e45|->edge45}
   
   w1nodes : Nodes = {|->}
   w2nodes : Nodes = {n1|->node1, n2|->node2}
   w3nodes : Nodes = {n1|->node1, n2|->node2}
   w4nodes : Nodes = {n1|->node1, n2|->node2, n3|->node3}
   w5nodes : Nodes = {n1|->node1, n2|->node2, n3|->node3}
   w6nodes : Nodes = {n1|->node1, n2|->node2, n3|->node3, n4|->node4}
  
   w1edges :Edges = {|->}
   w2edges :Edges = {e12|->edge12}
   w3edges :Edges = {e12|->edge12, e21 |->edge21}
   w4edges :Edges = {e12|->edge12, e23|->edge23, e31|->edge31}
   w5edges :Edges = {e12|->edge12}
   w6edges :Edges = {e12|->edge12, e34|->edge34}
