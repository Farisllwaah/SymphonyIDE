[{"poKind":"non-zero","poExp":"(forall p1:nat, p2:nat, p3:bool \u0026 (p3 \u003d\u003e (p2 \u003c\u003e 0)))"},{"poKind":"non-zero","poExp":"(forall p1:nat, p2:nat, p3:bool \u0026 ((p3 \u003d\u003e ((p1 / p2) \u003e 0)) \u003d\u003e (exists result:nat \u0026 (p2 \u003c\u003e 0))))"},{"poKind":"function postcondition satisfiable","poExp":"(forall p1:nat, p2:nat, p3:bool \u0026 (pre_impF1(p1, p2, p3) \u003d\u003e (exists result:nat \u0026 post_impF1(p1, p2, p3, result))))"},{"poKind":"function establishes postcondition","poExp":"(forall n:nat, m:MapT \u0026 (forall n:nat, m:MapT \u0026 (pre_expF1(n, m) \u003d\u003e post_expF1(n, m, m(n)))))"},{"poKind":"legal map application","poExp":"(forall n:nat, m:MapT \u0026 (forall n:nat, m:MapT \u0026 ((n in set (dom m)) \u003d\u003e (n in set (dom m)))))"},{"poKind":"map compatible","poExp":"(forall m1:MapT, m2:MapT \u0026 (forall ldom1 in set (dom m1), rdom2 in set (dom m2) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m1(ldom1) \u003d m2(rdom2)))))"},{"poKind":"non-zero","poExp":"(forall n:nat, s:SeqT \u0026 (((len s) \u003e n) \u003d\u003e (n \u003c\u003e 0)))"},{"poKind":"non-zero","poExp":"(forall n:nat, s:SeqT \u0026 (forall n:nat, s:SeqT \u0026 ((((len s) \u003e n) and (((len s) / n) \u003e 4)) \u003d\u003e (n \u003c\u003e 0))))"},{"poKind":"legal sequence application","poExp":"(forall n:nat, s:SeqT \u0026 (forall n:nat, s:SeqT \u0026 ((((len s) \u003e n) and (((len s) / n) \u003e 4)) \u003d\u003e ((((len s) / n) \u003e 4) \u003d\u003e (n in set (inds s))))))"},{"poKind":"sequence modification","poExp":"(forall s:SeqT, m:MapT \u0026 ((dom m) subset (inds s)))"},{"poKind":"legal function application","poExp":"(forall n:nat \u0026 pre_expF3(n, []))"},{"poKind":"map iteration","poExp":"(forall m:MapT, n:nat \u0026 (((m ** n) \u003d 0) null (((m ** n) \u003d 1) null ((rng m) null (dom m)))))"},{"poKind":"non-empty sequence","poExp":"(forall s:SeqT \u0026 (forall s:SeqT \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e []))))"},{"poKind":"non-empty set","poExp":"(forall setn:set of (set of (nat)) \u0026 (setn null {}))"},{"poKind":"cases exhaustive","poExp":"(forall e:EnumT \u0026 ((e \u003d \u003cA\u003e) or (e \u003d \u003cB\u003e)))"},{"poKind":"map compose","poExp":"(forall m:MapT2, m2:MapT3 \u0026 ((rng m) null (dom m2)))"},{"poKind":"enumeration map injectivity","poExp":"(forall m1, m2 in set {{1 |-\u003e 2}, {3 |-\u003e 4}, {4 |-\u003e 3}, {3 |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))"},{"poKind":"comprehension map injectivity","poExp":"(forall s:set of (MapT) \u0026 (forall m1, m2 in set s \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))"},{"poKind":"comprehension map injectivity","poExp":"(forall m1, m2 in set {{a |-\u003e b} | a:nat, b:nat \u0026 auxFunc(a, b)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))"},{"poKind":"finite map","poExp":"(exists finmap1:map (nat) to (map (nat) to (nat)) \u0026 (forall a:nat, b:nat \u0026 (auxFunc(a, b) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d {a |-\u003e b})))))"},{"poKind":"finite set","poExp":"(exists finmap1:map (nat) to (nat) \u0026 (forall a:nat \u0026 (auxFunc2(a) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d a)))))"},{"poKind":"legal function application","poExp":"(forall n:nat \u0026 pre_((auxFunc3 ** n)0))"},{"poKind":"function iteration","poExp":"(forall n:nat \u0026 ((n \u003e 1) \u003d\u003e (forall arg1:nat \u0026 (pre_auxFunc3(arg1) \u003d\u003e pre_auxFunc3(arg1)(auxFunc3(arg1))))))"},{"poKind":"legal function application","poExp":"(forall n:nat \u0026 pre_((auxFunc4a comp auxFunc4b)n))"},{"poKind":"function compose","poExp":"(forall n:nat \u0026 (forall arg1:nat \u0026 (pre_auxFunc4b(arg1) \u003d\u003e pre_auxFunc4a(auxFunc4b(arg1)))))"},{"poKind":"function postcondition satisfiable","poExp":"(forall n:nat \u0026 (pre_auxFunc4a(n) \u003d\u003e (exists rs:nat \u0026 post_auxFunc4a(n, rs))))"},{"poKind":"function postcondition satisfiable","poExp":"(forall n:nat \u0026 (pre_auxFunc4b(n) \u003d\u003e (exists rs:nat \u0026 post_auxFunc4b(n, rs))))"},{"poKind":"legal sequence application","poExp":"(1 in set (inds sq1))"},{"poKind":"value binding","poExp":"(exists mk_(x, y):((nat1 * nat1) | nat1) \u0026 (mk_(x, y) \u003d sq1(1)))"},{"poKind":"type compatibility","poExp":"is_(sq1(1), (nat1 * nat1))"},{"poKind":"state invariant","poExp":"(n2 \u003e 4)"},{"poKind":"state invariant satisfiable","poExp":"(exists n2:nat \u0026 (n2 \u003e 4))"},{"poKind":"non-empty sequence","poExp":"((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e []))"},{"poKind":"operation satisfiability","poExp":"(forall s:SeqT, n2:nat \u0026 (((s \u003c\u003e []) and (n2 \u003e 4)) \u003d\u003e (exists n21:nat, r:nat \u0026 ((r \u003d (hd s)) and (n21 \u003e 4)))))"},{"poKind":"non-empty sequence","poExp":"(forall s:SeqT, n2:nat \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e [])))"},{"poKind":"non-empty sequence","poExp":"(forall s:SeqT, n2:nat \u0026 ((s \u003c\u003e []) \u003d\u003e (s \u003c\u003e [])))"},{"poKind":"function establishes postcondition","poExp":"(forall s:SeqT, n2:nat \u0026 ((s \u003c\u003e []) \u003d\u003e (RESULT \u003d (hd s))))"},{"poKind":"while loop termination","poExp":"NotYetImplemented"},{"poKind":"state invariant","poExp":"(forall seqT:SeqT, n2:nat \u0026 (n2 \u003e 4))"},{"poKind":"non-empty sequence","poExp":"(forall seqT:SeqT, n2:nat \u0026 (s \u003c\u003e []))"},{"poKind":"state invariant","poExp":"(forall seqT:SeqT, n2:nat \u0026 (n2 \u003e 4))"},{"poKind":"non-empty sequence","poExp":"(forall seqT:SeqT, n2:nat \u0026 (s \u003c\u003e []))"},{"poKind":"unique existence binding","poExp":"(forall setT:SetT, n2:nat \u0026 (exists1 x in set setT \u0026 (x \u003e 1)))"},{"poKind":"state invariant","poExp":"(forall n:nat, n2:nat \u0026 (n2 \u003e 4))"}]