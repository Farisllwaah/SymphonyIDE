/**
 * Proof Obligation Generator Analysis
 *
 * Description: 
 * 
 * This analysis extends the QuestionAnswerAdaptor to generate
 * POs from the AST generated by the CML parser
 *
 */

package eu.compassresearch.core.analysis.pog.visitors;

// Java libraries 
import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import org.overture.ast.analysis.AnalysisException;
import org.overture.ast.definitions.PDefinition;
import org.overture.ast.expressions.ACaseAlternative;
import org.overture.ast.expressions.PExp;
import org.overture.ast.expressions.PModifier;
import org.overture.ast.modules.AModuleModules;
import org.overture.ast.modules.PExport;
import org.overture.ast.modules.PExports;
import org.overture.ast.modules.PImports;
import org.overture.ast.modules.PModules;
import org.overture.ast.patterns.ASetBind;
import org.overture.ast.patterns.ASetMultipleBind;
import org.overture.ast.patterns.ATypeBind;
import org.overture.ast.patterns.ATypeMultipleBind;
import org.overture.ast.patterns.PBind;
import org.overture.ast.patterns.PPair;
import org.overture.ast.patterns.PPattern;
import org.overture.ast.patterns.PPatternBind;
import org.overture.ast.statements.AMapSeqStateDesignator;
import org.overture.ast.statements.ATixeStmtAlternative;
import org.overture.ast.statements.PCase;
import org.overture.ast.statements.PClause;
import org.overture.ast.statements.PObjectDesignator;
import org.overture.ast.statements.PStateDesignator;
import org.overture.ast.statements.PStm;
import org.overture.ast.types.PAccessSpecifier;
import org.overture.ast.types.PField;
import org.overture.ast.types.PType;
import org.overture.pog.IPOContextStack;
import org.overture.pog.IProofObligationList;
import org.overture.pog.PDefinitionAssistantPOG;
import org.overture.pog.POCaseContext;
import org.overture.pog.POContextStack;
import org.overture.pog.PONotCaseContext;
import org.overture.pog.SeqApplyObligation;

import eu.compassresearch.ast.actions.PAction;
import eu.compassresearch.ast.analysis.QuestionAnswerCMLAdaptor;
import eu.compassresearch.ast.declarations.PSingleDeclaration;
import eu.compassresearch.ast.expressions.PVarsetExpression;
import eu.compassresearch.ast.process.PProcess;
import eu.compassresearch.ast.program.AFileSource;
import eu.compassresearch.ast.program.AInputStreamSource;
import eu.compassresearch.ast.program.PSource;
import eu.compassresearch.core.analysis.pog.obligations.CMLProofObligationList;

public class ProofObligationGenerator extends
		QuestionAnswerCMLAdaptor<IPOContextStack, CMLProofObligationList>
{
	/**
	 * Main generator class for the POG. Receives the sources to be checked, visits them and dispatches them to the
	 * various subvisitors.
	 */
	private static final long serialVersionUID = -4538022323752020155L;

	private final static String ANALYSIS_NAME = "Proof Obligation Generator";

	private List<PSource> sourceForest;

	// ---------------------------------------------
	// -- Proof Obligation Generator State
	// ---------------------------------------------

	// subvisitors
	private POGExpressionVisitor expressionVisitor;
	private POGStatementVisitor statementVisitor;
	private POGProcessVisitor processVisitor;
	private POGDeclAndDefVisitor declAndDefVisitor;
	private POGActionVisitor actionVisitor;

	private void initialize()
	{
		expressionVisitor = new POGExpressionVisitor(this);
		statementVisitor = new POGStatementVisitor(this);
		processVisitor = new POGProcessVisitor(this);
		declAndDefVisitor = new POGDeclAndDefVisitor(this);
		actionVisitor = new POGActionVisitor(this);
	}

	// ---------------------------------------------
	// -- Dispatch to sub-visitors
	// ---------------------------------------------

	// Duplicated main overture handlers. Necessary for now since we don't want
	// to
	// switch visitor context at the root level

	@Override
	public CMLProofObligationList defaultPDefinition(PDefinition node,
			IPOContextStack question) throws AnalysisException
	{
		return node.apply(this.declAndDefVisitor, question);
	}

	@Override
	public CMLProofObligationList defaultPSingleDeclaration(
			PSingleDeclaration node, IPOContextStack question)
			throws AnalysisException
	{
		return node.apply(this.declAndDefVisitor, question);
	}

	@Override
	public CMLProofObligationList caseAModuleModules(AModuleModules node,
			IPOContextStack question) throws AnalysisException
	{
		IProofObligationList ovtpos = assistantFactory.createPDefinitionAssistant.getProofObligations(node.getDefs(), this.declAndDefVisitor, question);
		CMLProofObligationList cmlpos = new CMLProofObligationList();
		cmlpos.addAll(ovtpos);
		
		return cmlpos;
	}

	@Override
	public CMLProofObligationList defaultPProcess(PProcess node,
			IPOContextStack question) throws AnalysisException
	{
		return node.apply(this.processVisitor, question);
	}

	@Override
	public CMLProofObligationList defaultPAction(PAction node,
			IPOContextStack question) throws AnalysisException
	{
		return node.apply(this.actionVisitor, question);
	}

	@Override
	public CMLProofObligationList defaultPStm(PStm node,
			IPOContextStack question) throws AnalysisException
	{
		return node.apply(this.statementVisitor, question);
	}

	@Override
	public CMLProofObligationList defaultPExp(PExp node,
			IPOContextStack question) throws AnalysisException
	{
		return node.apply(this.expressionVisitor, question);
	}

	@Override
	public CMLProofObligationList caseASetBind(ASetBind node,
			IPOContextStack question) throws AnalysisException
	{
		return node.getSet().apply(this.expressionVisitor, question);
	}

	@Override
	public CMLProofObligationList caseASetMultipleBind(ASetMultipleBind node,
			IPOContextStack question) throws AnalysisException
	{
		return node.getSet().apply(this.expressionVisitor, question);
	}

	// FIXME --what are pvarsets?
	@Override
	public CMLProofObligationList defaultPVarsetExpression(
			PVarsetExpression node, IPOContextStack question)
			throws AnalysisException
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList caseACaseAlternative(ACaseAlternative node,
			IPOContextStack question) throws AnalysisException
	{

		CMLProofObligationList obligations = new CMLProofObligationList();

		question.push(new POCaseContext(node.getPattern(), node.getType(), node.getCexp()));
		obligations.addAll(node.getResult().apply(this.expressionVisitor, question));
		question.pop();
		question.push(new PONotCaseContext(node.getPattern(), node.getType(), node.getCexp()));

		return obligations;
	}

	@Override
	public CMLProofObligationList caseAMapSeqStateDesignator(
			AMapSeqStateDesignator node, IPOContextStack question)
			throws AnalysisException
	{

		CMLProofObligationList list = new CMLProofObligationList();

		if (node.getSeqType() != null)
		{
			list.add(new SeqApplyObligation(node.getMapseq(), node.getExp(), question));
		}

		// Maps are OK, as you can create new map domain entries

		return list;
	}

	@Override
	public CMLProofObligationList caseATixeStmtAlternative(
			ATixeStmtAlternative node, IPOContextStack question)
			throws AnalysisException
	{

		CMLProofObligationList list = new CMLProofObligationList();

		if (node.getPatternBind().getPattern() != null)
		{
			// Nothing to do
		} else if (node.getPatternBind().getBind() instanceof ATypeBind)
		{
			// Nothing to do
		} else if (node.getPatternBind().getBind() instanceof ASetBind)
		{
			ASetBind bind = (ASetBind) node.getPatternBind().getBind();
			list.addAll(bind.getSet().apply(this.expressionVisitor, question));
		}

		list.addAll(node.getStatement().apply(this.statementVisitor, question));
		return list;

	}

	// Return empty lists for a bunch of stuff...

	@Override
	public CMLProofObligationList defaultPModifier(PModifier node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPType(PType node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPField(PField node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPAccessSpecifier(
			PAccessSpecifier node, IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPPattern(PPattern node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPPair(PPair node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPBind(PBind node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList caseATypeMultipleBind(ATypeMultipleBind node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPPatternBind(PPatternBind node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPModules(PModules node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPImports(PImports node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPExports(PExports node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPExport(PExport node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPStateDesignator(
			PStateDesignator node, IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPObjectDesignator(
			PObjectDesignator node, IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPClause(PClause node,
			IPOContextStack question)
	{

		return new CMLProofObligationList();
	}

	@Override
	public CMLProofObligationList defaultPCase(PCase node,
			IPOContextStack question)
	{
		return new CMLProofObligationList();
	}

	// ---------------------------------------------
	// -- Public API to CML POG
	// ---------------------------------------------
	// Taken from Type Checker code
	// ---------------------------------------------
	/**
	 * This method is invoked by the command line tool when pretty printing the analysis name.
	 * 
	 * @return Pretty short name for this analysis.
	 */
	public String getAnalysisName()
	{
		return ANALYSIS_NAME;
	}

	/**
	 * Construct a ProofObligationGenerator with the intension of checking a list of PSources. These source may refer to
	 * each other.
	 * 
	 * @param cmlSources
	 *            - Sources containing CML Paragraphs for PO gen.
	 */
	public ProofObligationGenerator(List<PSource> cmlSources)
	{
		initialize();
		this.sourceForest = cmlSources;
	}

	/**
	 * Construct a ProofObligationGenerator with the intension of checking a single source.
	 * 
	 * @param singleSource
	 *            - Source containing CML Paragraphs for PO gen.
	 */
	public ProofObligationGenerator(PSource singleSource)
	{
		initialize();
		this.sourceForest = new LinkedList<PSource>();
		this.sourceForest.add(singleSource);
	}

	/**
	 * Run the proof obligation generator. The POs are placed in the return value but we may eventually want to switch
	 * them over to the registry
	 * 
	 * @return - Returns CMLProofObligation list. This may need to change.
	 */
	public CMLProofObligationList generatePOs() throws AnalysisException
	{
		CMLProofObligationList obligations = new CMLProofObligationList();
		IPOContextStack ctxt = new POContextStack();

		// for each source
		for (PSource s : sourceForest)
		{
			// for each CML paragraph
			for (PDefinition paragraph : s.getParagraphs())
			{
				try
				{
					System.out.println("--------------------------------PROCESSING--------------------------------");
					System.out.println(paragraph.toString());
					System.out.println("------------------------------------RESULT----------------------------------");

					// process paragraph:
					obligations.addAll(paragraph.apply(this, ctxt));
					// obligations.addAll(paragraph.apply(overturePog, ctxt));

					System.out.println();
					System.out.println();
				} catch (AnalysisException ae)
				{
					// This means we have a bug in the pog
					System.out.println("The COMPASS Proof Obligation Generator failed on this cml-source. Please submit it for investigation to richard.payne@ncl.ac.uk.\n");
					throw ae;
				}
			}
		}

		System.out.println(obligations.size() + " Proof Obligations generated");
		System.out.println(obligations.toString());
		return obligations;
	}

	// ensure drilldown to children (this is probably not needed)
	// @Override
	// public CMLProofObligationList defaultINode(INode node,
	// POContextStack question) throws AnalysisException {
	// CMLProofObligationList obligations = new CMLProofObligationList();
	// Stack<INode> workQ = new Stack<INode>();
	// for (Object o : node.getChildren(true).values()) {
	// workQ.push((INode) o);
	// }
	// while (!workQ.isEmpty()) {
	// INode aux = workQ.pop();
	// obligations.addAll(aux.apply(this, question));
	//
	// }
	// return obligations;
	// }

	// ---------------------------------------------
	// Static stuff for running the POG from Eclipse
	// ---------------------------------------------
	// Taken from Type Checker code
	// ---------------------------------------------

	// setting the file on AFileSource allows the POG to interact with it
	// TODO this method is a duplicate( from VanillaTypeChecker). Should be
	// placed in a common utils lib
	private static PSource prepareSource(File f)
	{
		if (f == null)
		{
			AInputStreamSource iss = new AInputStreamSource();
			iss.setStream(System.in);
			iss.setOrigin("stdin");
			return iss;
		} else
		{
			AFileSource fs = new AFileSource();
			fs.setName(f.getName());
			fs.setFile(f);
			return fs;
		}
	}

	/**
	 * This method runs the PO generator on a given file. The method invokes methods to generate POs.
	 * 
	 * @param f
	 *            - The file to generate POs
	 */
	// TODO this method is a duplicate( from VanillaTypeChecker). Should be
	// placed in a common utils lib
	private static void runOnFile(File f) throws IOException
	{
		// set file name
		PSource source = prepareSource(f);

		// generate POs
		ProofObligationGenerator cmlPOG = new ProofObligationGenerator(source);
		try
		{
			cmlPOG.generatePOs();
		} catch (AnalysisException e)
		{
			System.out.println("The COMPASS Proof Obligation Generator failed on this cml-source. Please submit it for investigation to richard.payne@ncl.ac.uk.\n");
			e.printStackTrace();
		}

		// Report success
		System.out.println("Proof Obligation Generation is complete for the given CML Program");
	}

	/**
	 * Main method for class. Current test class takes a set of cml examples and generates POs for each
	 */
	// TODO the body of this method is a duplicate (from VanillaTypeChecker)
	public static void main(String[] args) throws IOException
	{
		File cml_examples = new File("../../docs/cml-examples");
		int failures = 0;
		int successes = 0;
		// runOnFile(null);

		if (cml_examples.isDirectory())
		{
			for (File example : cml_examples.listFiles())
			{
				System.out.print("Generating Proof Obligations for example: "
						+ example.getName() + " \t\t...: ");
				System.out.flush();
				try
				{
					runOnFile(example);
					System.out.println("done");
					successes++;
				} catch (Exception e)
				{
					System.out.println("exception");
					failures++;
				}
			}
		}

		System.out.println(successes + " was successful, " + failures
				+ " was failures.");
	}
}
