-- Travel agent case study
-- Flight booking system

-- Authors: Steve Riddle and John Nicholson
-- Newcastle University
--------------------------

types

public Aircraft = token

public Date = token

public Airport = token

-- a graph of connected airports
public Connections = map Airport to set of Airport
inv conn == forall a in set dom conn @ 
        not a in set conn(a)   -- not reflexive
        and (forall b in set conn(a) @ b in set dom conn and a in set conn(b)) -- symmetric
 
-- Flights depart from / arrive at Airports on 
-- respective dates (date notionally includes time of day). 
-- Record number of booked seats and total available seats  
public Flight :: departure : Airport
          departDate : Date
          arrival : Airport
          arriveDate: Date
          totalSeats: nat
          bookedSeats: nat
inv f == f.departure <> f.arrival 
         and f.totalSeats >= f.bookedSeats


-- Route = seq of Flight -- not currently used

public FlightId = token
public ReservationNumber = token

public ReservationData :: flight: FlightId
                   numSeats: nat1
inv f == true
				   
public Agent = token 

public Price = nat

-- process related types
-- not currently used
public BookingStatus = ((<provisional> | <takingPayment>) | <confirmed>)

functions
FreeSeats: Flight -> nat
FreeSeats(f) == f.totalSeats - f.bookedSeats

MaxSeats: Flight -> nat
MaxSeats(f) == f.totalSeats

--- calculate price for n seats
CalculatePrice: nat -> Price
CalculatePrice(n) ==
  let c = 50 in -- hardcoded price for 1 seat
    n * c


channels 
bookEnquire: (Airport*Airport*Date*nat)
makeBooking: (FlightId*nat)
response: FlightId
confirmation: ReservationNumber
payment: (ReservationNumber*Price)
failBooking failPayment failCancel
cancel: ReservationNumber

chansets
C = {|bookEnquire, makeBooking, confirmation, cancel, payment, response, failBooking, failPayment, failCancel|}

process airline2 =
begin
 state 
   connections : Connections
   flights : map FlightId to Flight
   authorisedAgents : set of Agent
   bookings : map ReservationNumber to ReservationData
 inv forall f in set rng flights @ f.departure in set dom connections
                                 and f.arrival in set connections(f.departure)
   and
   -- bookings for valid flights
   (forall r in set dom bookings @ bookings(r).flight in set dom flights)
   
 operations

-- Given travel reqts (from, to, date) suggest a flight
FindFlight (dep: Airport, arr: Airport, date: Date, n: nat) f: [FlightId]
frame rd flights 
post let
	fids : set of FlightId = { id | id in set dom flights @ 
	       	      	       	          flights(id).departure = dep  and 
					  flights(id).arrival   = arr  and 
					  flights(id).date      = date and
			n + FreeSeats(flights(id)) <= MaxSeats(flights(id))
			          }

     in
	if fids <> {} then f = nil
	   	      else f = nil

-- post if exists fid in set dom flights @ 
--       flights(fid).departure = dep and
--       flights(fid).arrival = arr and
--       flights(fid).date = date -- using simple idea of matching dates for now
--       and n + FreeSeats(flights(fid)) <= MaxSeats(flights(fid)) -- enough seats
-- RWL TC: f=fid in the then-clause is outside scope of fid.
--     then f = fid 
--     else f = nil


  --check to see if the agent is an authorised agent. Not currently used.
 Agent_check (a: agent) b:bool
 frame rd authorisedAgents
 post b <=> (a in set authorisedAgents)

 -- book a number of seats. 
 -- reservation number is generated by operation.
 BookSeats (n: nat, f: FlightId) r: ReservationNumber
 frame wr flights, bookings
 pre SeatsAvailable(n,f) 
 post flights(f).bookedSeats = flights(f).bookedSeats + n and
      r not in set dom bookings~ --and      
--      bookings = (bookings~ munion ({r |-> mk_ReservationData(f, n)}));
 -- munion not parsing???
       

-- cancel a booking
CancelBooking (r: ReservationNumber)
frame wr bookings, flights
pre r in set dom bookings
post bookings = bookings <-: {r}  -- remove r from bookings
     and flights(bookings(r).flight).bookedSeats = 
          flights(bookings(r).flight).bookedSeats - flights(bookings(r).numSeats)


-- take payment 
TakePayment (r: ReservationNumber, p: Price)
--- payment happens, but details are out of scope
post true

actions 
  BOOK = 
  bookEnquire?mk_(dep,arr,d,n) -> (dcl f: FlightId @ f := FindFlight(dep,arr,t,d,n); response!f -> BOOK)
  []
  makeBooking?mk_(f,n) ->
         ([ pre_BookSeats(n,f)] & (dcl r:ReservationId @ r:= BookSeat(f,s); 
                                   (dcl c:Price @ c := CalculatePrice(n); payment!(mk_(r,c)) ->  BOOK)))
         []
         ([ not pre_BookSeats(n,f) ] & failBooking -> BOOK)
  []
  cancel?r -> 
       --  ([ pre_CancelBooking(r)] & CancelBooking(r) ; BOOK)
	--	 []
		 ([ not pre_CancelBooking(r)] & failCancel -> BOOK)
 
-- If TakePayment times out after time t, signal failPayment. Otherwise output 
-- reference r as confirmation. In both cases PAY process continues (so this syntax isn't right) 
--  PAY = payment?mk_(r,c) -> ((TakePayment(r,c) ; (confirmation!r -> PAY)) [_ t _> (failPayment -> PAY))
  PAY = payment?mk_(r,c) -> (TakePayment(r,c) ; confirmation!r -> PAY) [_ t _> failPayment -> PAY
   @
		init -> BOOK || PAY

end

channels
    init