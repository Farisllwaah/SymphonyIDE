types
  Command = Borrow | Renew | Return | Find
  
  String = seq of char
  BookId = token
  UserId = token
  BorrowMap = map UserId to set of BookId
  
  Book ::
    title : String
    author : String

  User ::
      name : String
      
  Borrow ::
    copy : BookId
    user : UserId
  
  Renew ::
    copy : BookId
    user : UserId
  Return :: copy : BookId
  Find :: string : String
  
  Library ::
    books : map BookId to Book
    users : map UserId to User
    borrowed : BorrowMap
  inv mk_Library(bs,us,bor) ==
    dom bor subset dom us
    and dunion rng bor subset dom bs
    and (forall u1, u2 in set dom bor @ u1 <> u2 => bor(u1) inter bor(u2) = {})
    
  values
  user1 = mk_User("User1")
  user2 = mk_User("User2")
  book1 = mk_Book("Book1", "Author1")
  book2 = mk_Book("Book2", "Author2")
  users = {mk_token(user1) |-> user1, mk_token(user2) |-> user2}
  books = {mk_token(book1) |-> book1, mk_token(book2) |-> book2}
  
  functions
  ExeBorrow: Borrow * Library -> Library
  ExeBorrow(b,l) ==
    mk_Library(l.books,
               l.users,
               l.borrowed++{b.user |-> BorrowCopy(b.user,b.copy,l.borrowed)})
  pre
    b.copy in set dom l.books
    and b.user in set dom l.users
    and b.copy not in set dunion rng l.borrowed
    
  BorrowCopy: UserId * BookId * BorrowMap -> (set of BookId)
  BorrowCopy(u,c,bor) ==
    if u in set dom bor
    then bor(u) union {c}
    else {c}
    
  ExeReturn: Return * Library -> Library
  ExeReturn(r, l) ==
    mk_Library(l.books,l.users,RemoveCopy(r.copy,l.borrowed))
  pre r.copy in set dom l.books

  RemoveCopy: BookId * BorrowMap -> BorrowMap
  RemoveCopy(c,bor) ==
    {u |-> bor(u) \ {c} | u in set dom bor}
    
  ExeFind: String * Library -> (set of BookId)
  ExeFind(s,l) ==
    {bid | bid in set dom l.books @ s in set {l.books(bid).title, l.books(bid).author}}
    
  channels
  init
  borrow: Borrow
  retBook: Return
  find: Find
  renew: Renew	
  loans: UserId*nat
  
  process LibraryProcess = begin
  state 
  findResult: set of BookId
  library: Library
  inv
    dom(library.borrowed) = dom(library.users)
    and rng(library.borrowed) subset dom(library.books)
    
  functions	
    GetBorrowed: Library -> BorrowMap
    GetBorrowed(l) == l.borrowed
		
    ApplyBorrowed: Library*UserId -> (set of BookId)
    ApplyBorrowed(l,u) == (GetBorrowed(l))(u)
    
    operations
    Init(bs: map BookId to Book, us: map UserId to User)
    post library = mk_Library(bs,us,{|->})
    
    actions
    Act =
      ( 
        borrow?b -> [pre_ExeBorrow(b,library)] & (library := ExeBorrow(b,library))
        []
        renew?r -> [pre_ExeReturn(r,library)] & 
          (library := ExeReturn(r,library);
           library := ExeBorrow(r,library))
        []
        retBook?r -> [pre_ExeReturn(r,library)] & library := ExeReturn(r,library)
        []
        find?f -> [pre_ExeFind(f,library)] & findResult := ExeFind(f,library)
        []
        loans?u !(card(ApplyBorrowed(library,u))) -> [ (u in set dom(GetBorrowed(library))) ] & Skip
      ); Act
	
  @
    init -> Init(books,users); Act
end